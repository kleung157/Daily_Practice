C Practice Exercises

############################################################################################################

Source:
C Programming for Everybody - Implement a Python str class

Question:
You will a set of supporting functions using the following structure to implement a subset of the Python str class in C. 
Some code and method signatures have been provided for you as well as a main() program and some support routines from the lecture slides. 
In the constructor, you will allocate a 10 character buffer. 
If as data is added, it exceeds the length of the buffer use realloc() to expand the buffer by 10. T
here is a good deal of discussion of this application in the lecture materials associated with this assignment.

Python Code:
x = str()
x = x + 'H'
print(x)
x = x + 'ello world'
print(x)
x = 'A completely new string'
print("String = ", x)
print("Length = ", len(x))

C Code:
**Attempt #1
#include <string.h>
/* x = x + 'h'; */

void pystr_append(struct pystr* self, char ch) {
    /* Need about 10 lines of code here */
    self->data[self->length] = self->data[self->length] + ch;
    self->length++;
    if ( self->length >= (self->alloc - 2) ) {
        self->alloc = self->alloc + 10;
        self->data = (char *)
            realloc(self->data, self->alloc);
    }
}

/* x = x + "hello"; */

void pystr_appends(struct pystr* self, char *str) {
    /* Need a line or two of code here */
    int alloc = self->alloc;
    for (self->length=0; self->length <= alloc; ) {
         pystr_append(self, str[self->length-1]);
    }
}

/* x = "hello"; */

void pystr_assign(struct pystr* self, char *str) {
    /* Need about three lines of code here */
    self->data[0] = '\0';
    self->alloc = 22;
    pystr_appends(self, str);
    strcpy(self->data, str);
}


** Solution #1
#include <stdio.h>
#include <stdlib.h>

struct pystr
{
    int length;
    int alloc; /* the length of *data */
    char *data;
};

/* Constructor - x = str() */
struct pystr * pystr_new() {
    struct pystr *p = malloc(sizeof(*p));
    p->length = 0;
    p->alloc = 10;
    p->data = malloc(10);
    p->data[0] = '\0';
    return p;
}

/* Destructor - del(x) */
void pystr_del(const struct pystr* self) {
    free((void *)self->data); /* free string first */
    free((void *)self);
}

void pystr_dump(const struct pystr* self)
{
    printf("Pystr length=%d alloc=%d data=%s\n",
            self->length, self->alloc, self->data);
}

int pystr_len(const struct pystr* self)
{
    return self->length;
}

char *pystr_str(const struct pystr* self)
{
    return self->data;
}

int main(void)
{
    setvbuf(stdout, NULL, _IONBF, 0);  /* Internal */

    struct pystr * x = pystr_new();
    pystr_dump(x);

    pystr_append(x, 'H');
    pystr_dump(x);

    pystr_appends(x, "ello world");
    pystr_dump(x);

    pystr_assign(x, "A completely new string");
    printf("String = %s\n", pystr_str(x));
    printf("Length = %d\n", pystr_len(x));
    pystr_del(x);
}

/* x = x + 'h'; */

void pystr_append(struct pystr* self, char ch) {
    // Check if reallocation is needed
    if ( self->length + 1 >= self->alloc ) {
        self->alloc = self->alloc + 10;
        self->data = (char *)
            realloc(self->data, self->alloc);
    }
    // Append the character
    self->data[self->length] = ch; 
    // Increment the length
    self->length++;
    // Ensure string is null-terminated
    self->data[self->length] = '\0';
}

/* x = x + "hello"; */

void pystr_appends(struct pystr* self, char *str) {
    int i;
    // Iterate through the string using a counter
    for (i=0; str[i] != '\0'; i++) {
         pystr_append(self, str[i]);
    }
}

/* x = "hello"; */

void pystr_assign(struct pystr* self, char *str) {
    // Clear existing string and reset length
    self->data[0] = '\0';
    self->length = 0;
    // Copy the new string
    pystr_appends(self, str);
}

Input:
N/A

Output:
Pystr length=0 alloc=10 data=
Pystr length=1 alloc=10 data=H
Pystr length=11 alloc=20 data=Hello world
String = A completely new string
Length = 23

Notes:
- The lecture provided the code for increasing the allocation. If the length started to exceed the allocation
  then the realloc() function was used to add 10 more to the allocated memory amount. I used that to initially
  start writing the pystar_append() function. The pystar_append() function involved using numerous pointers 
  and incrementing. 
- For the pystr_appends() function, I used a for loop and had to make sure the alloc was an integer and 
  assigned to a variable or else the for loop condition would not recognize self->alloc as the value 10. 
  Only when I assigned int alloc = self->alloc did it recognize it as 10. This for loop also ran the 
  pystr_append() function repeatedly to affix the string to the variable. 
- The pystar_assign() was a lot trickier and I couldn't quite figure out how to do it without using the 
  string.h library and the dedicated strcpy() function. My end result was assigning the self->data to the 
  null terminator '\0' then reallocating manually for the allocation to the string size. After that, I called
  the pystr_appends() function and finally the strcpy() function. When I used pystr_dump() in the
  pystr_assign() function to check the printed length, alloc and data it had extra allocation by 2 and the
  allocation assignment that I needed for self->alloc was off by 1. Tried a while to look through the code
  and troubleshoot but couldn't quite figure out what was causing this discrepancy.

Suggestions and Final Thoughts:
- In the if statement for checking if reallocation is needed, another way to check if the new length will
   meet or exceed the allocation size is to use "if (self-> length + 1 >= self->alloc)".
- Rather than performing arithmetic for assigning the appending of characters in the line
  "self->data[self->length] = self->data[self->length] + ch;", it is best to just assign the character to
  the variable using "self->data[self->length] = ch;". 
- When strings are modified, it is best to ensure the string is null-terminated using '\0' as in the line
  "self->data[self->length] = '\0'
- Initially, I created a for loop by using an initializer integer variable i but for some reason had tried
  to incorporate the self->length variable into the for loop which ended up being too complicated. Sticking
  with the variable i ensures there's no mix up in the function itself. The for loop ended up being a 
  traversal through a string until the end of the string itself, or the null terminator and incremented each
  time. It also called the pystr_append() function multiple times to carry out the appending operation.
- For the pystr_assign() function, I had the correct logic when I made my first few attempts but my
  pystr_appends() and pystr_append() functions did not correspond correctly so it would throw off the 
  final result. I did use the null terminator for self->data[0] and self->length = 0 along with calling the
  pystr_appends() function within pystr_assign() function.
- Seems like overall, I made the problem a little more difficult than I needed to by trying to incorporate
  all the pointers that I could but some functions didn't need to have the pointers. Still was good practice
  and challenge in the end.

############################################################################################################

Source:
C Programming for Everybody - Implement a Python list class

Question:
You will a set of supporting functions using the following structures to implement a subset of the Python list class in C. 
Some code and method signatures have been provided for you as well as a main() program and some support routines from the lecture slides. 
There is a good deal of discussion of this application in the lecture materials associated with this assignment.

Python Code:
lst = list();
lst.append("Hello world");
print(lst)
lst.append("Catch phrase");
print(lst)
lst.append("Brian");
print(lst)
print("Length =", len(lst);

print("Brian?", lst.index("Brian"));

if "Bob" in lst:
    print("Bob?", lst.index("Bob"));
else:
    print("Bob? 404");

C Code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct lnode {
    char *text;
    struct lnode *next;
};

struct pylist {
  struct lnode *head;
  struct lnode *tail;
  int count;
};

/* Constructor - lst = list() */
struct pylist * pylist_new() {
    struct pylist *p = malloc(sizeof(*p));
    p->head = NULL;
    p->tail = NULL;
    p->count = 0;
    return p;
}

/* Destructor - del(lst) */
void pylist_del(struct pylist* self) {
    struct lnode *cur, *next;
    cur = self->head;
    while(cur) {
        free(cur->text);
        next = cur->next;
        free(cur);
        cur = next;
    }
    free((void *)self);
}

int main(void)
{
    setvbuf(stdout, NULL, _IONBF, 0);  /* Internal */

    struct pylist * lst = pylist_new();
    pylist_append(lst, "Hello world");
    pylist_print(lst);
    pylist_append(lst, "Catch phrase");
    pylist_print(lst);
    pylist_append(lst, "Brian");
    pylist_print(lst);
    printf("Length = %d\n", pylist_len(lst));
    printf("Brian? %d\n", pylist_index(lst, "Brian"));
    printf("Bob? %d\n", pylist_index(lst, "Bob"));
    pylist_del(lst);
}

/* print(lst) */
void pylist_print(struct pylist* self)
{
    int i;
    struct lnode *cur;
    printf("[");
    /* Loop until the current pointer reaches NULL, 
    NULL signifies end of list */
    for(i=0, cur=self->head; cur != NULL; cur=cur->next, i++) { 
        printf("'%s'", cur->text);
        /* Place commas only between list entries */
        if ( i < self->count-1 ) {
            printf(", ");
        }
    }
    printf("]\n");
}

/* len(lst) */
int pylist_len(const struct pylist* self)
{
    return self->count;
}

/* lst.append("Hello world") */
void pylist_append(struct pylist* self, char *str) {
    /* Allocate space for save variable
       Copy string to "save"
       increment count by 1 */
    char *save = (char *) malloc(strlen(str)+1);
    strcpy(save, str);
    self->count++;
  
    /* Allocate space only for the new node */
    struct lnode *new = (struct lnode *)
        malloc(sizeof(struct lnode));
 
    /* Check if allocation failed */
    if ( new == NULL ) {
        return;
    }
  
    /* List is not empty.
       Append new node by updating current tail's 'next' pointer.
       Update the list's 'tail' pointer to be the new node. */
    if ( self->tail != NULL ) {
        self->tail->next = new;
        new->text = save;
        new->next = NULL;
        self->tail = new;
    }
   
    /* List is empty. 
       Head and tail point to the new node */
    if ( self->head == NULL ) {
        new->text = save;
        self->head = new;
        self->tail = new;
    }    
}

/* lst.index("Hello world") - if not found -1 */
int pylist_index(struct pylist* self, char *str)
{
    struct lnode *cur;
    int i;
    /* Loop until the current pointer reaches NULL, 
       NULL signifies end of list */
    for(i=0, cur=self->head; cur != NULL; cur=cur->next, i++) {
        /* Check if the current node contains the target value
           If value found, return the index */
        if ( strcmp(cur->text, str) == 0 ) {
            return i;
        }
    }
    /* If the loop finishes without finding the value, return -1*/
    return -1;
}

Input:
N/A

Output:
['Hello world']
['Hello world', 'Catch phrase']
['Hello world', 'Catch phrase', 'Brian']
Length = 3
Brian? 2
Bob? -1

Notes:
- I started this problem with working on the pylist.append() function first. As the lecture had hinted, one
  of the chapter 6 problems that I had done on linked lists had the code necessary to create this function.
  The modifications made were to allocate space for a save variable, copy the string to save and increment
  the list count by 1 each time it was called. Also, since this was a character string instead of a integer
  value, I had to change some of the pointer values to 'save' for situations where if the list was or was not
  empty such as with "new->text = save;"
- The pylist_len() function was straightforward, since I incremented the self->count each time I called
  pylist_append(), it was a matter of returning "self->count" to get the length of the list. 
- The next function I worked on was the pylist_print(), this was pretty tricky as it was like another
  problem I was working on before where I didn't use a counter variable and tried to use a pointer variable. 
  It helped tremendously to use i as a counter variable. Once I created a for loop to traverse a list, it was 
  a matter of where to put each individual printf() function to simulate the Python list output like [ , , ]. 
  The trickiest part was how to get the commas to be within entries and not on the outsides of entries. That's
  where the i counter variable really helped.
- The pylist_index() function was another function that was used before in Chapter 6 problems for scanning
  through a list. I took my existing for loop from the pylist_print() function and added a conditional if
  statement that compared the pointer values to the string being called using the strcmp() function. If the
  strings were the same then it would be 0, and the index i was returned when calling the function. If there
  was not a match after the loop finished then the function returned -1.

Suggestions and Final Thoughts:
- The lines "new->text = save;" and "new->next = NULL;" can be placed outside of the if statements for the
  lists being empty or not. It sets the new node's properties and prevents duplication.
- The conditional statements could be unified using if/else instead of two if statements since they both
  deal with NULL situations.
  ex.
      if (self->head == NULL) {
          self->head = new;    // List is EMPTY: The new node is the head
      } 
      else {
          self->tail->next = new;     // List is NOT empty: Link the old tail to the new node
      }
      self->tail = new;         // Update the list's tail 
- There is a check to see if allocation failed for new. There should also be one for save as well.
  ex. 
      if (save == NULL) { 
          return 
      }

############################################################################################################

Source:
C Programming for Everybody - Implement a Python dict class

Question:
You will create a set of supporting functions using the following structure to implement a subset of the Python dict class in C. 
Some code and method signatures have been provided for you as well as a main() program and some support routines from the lecture slides. 
There is a good deal of discussion of this application in the lecture materials associated with this assignment.

Python Code:
dct = dict();
dct["z"] = "Catch phrase"
print(dct);
dct["z"] = "W"
print(dct):
dct["y"] = "B"
dct["c"] = "C"
dct["a"] = "D"
print(dct);
print("Length =", len(dct));
print("z=", dct.get("z", 404))
print("x=", dct.get("x", 404))
print("\nDump")
for key in dct:
    print(key+"="+dct(key))

C Code:
Attempt #1 (only the pydict_put function was revised)
/* x[key] = value; Insert or replace the value associated with a key */
void pydict_put(struct pydict* self, char *key, char *value)
{
    struct dnode *old = pydict_find(self, key);
  
    // If old key found then replace the value
    if ( old != NULL ) {
        // Free the data in the old value before allocating the new value
        free(old->value);
      
        // Allocate space for new savevalue variable
        char *savevalue = (char *) malloc(strlen(value)+1);
      
        // Check if allocation failed 
        if ( savevalue == NULL ) {
            return;
        }
       
        // Copy new value to savevalue
        strcpy(savevalue, value);
    }
  
    // If old key not found then insert key and value
    else {
        // Allocate space for savekey and savevalue variables
        char *savekey = (char *) malloc(strlen(key)+1);
        char *savevalue = (char *) malloc(strlen(value)+1);
  
        // Check if allocation failed 
        if ( savekey == NULL ) {
            return;
        }
        if ( savevalue == NULL ) {
            return;
        }
  
        // Copy key to savekey and value to savevalue
        strcpy(savekey, key);
        strcpy(savevalue, value);
  
        // Allocate space for new node
        struct dnode *new = (struct dnode *)
            malloc(sizeof(struct dnode));
  
        // Check if allocation failed 
        if ( new == NULL ) {
            return;
        }
  
        // Set new node properties
        new->key = savekey;
        new->value = savevalue;
        new->next = NULL;
  
        // Dict is empty: The new node is the head
        if ( self->head == NULL ) {
            self->head = new;
        }
        // Dict not empty: Link the old tail to the new node
        else {
           self->tail->next = new;
        }
  
        // Update the dict's tail
        self->tail = new;
  
        // Increment the counter
        self->count++;
    }
}


**Solution #1 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct dnode {
    char *key;
    char *value;
    struct dnode *next;
};

struct pydict {
  struct dnode *head;
  struct dnode *tail;
  int count;
};

/* Constructor - dct = dict() */
struct pydict * pydict_new() {
    struct pydict *p = malloc(sizeof(*p));
    p->head = NULL;
    p->tail = NULL;
    p->count = 0;
    return p;
}

/* Destructor - del(dct) */
void pydict_del(struct pydict* self) {
    struct dnode *cur, *next;
    cur = self->head;
    while(cur) {
        free(cur->key);
        free(cur->value);
        next = cur->next;
        free(cur);
        cur = next;
    }
    free((void *)self);
}

int main(void)
{
    struct dnode * cur;
    struct pydict * dct = pydict_new();

    setvbuf(stdout, NULL, _IONBF, 0);  /* Internal */

    pydict_put(dct, "z", "Catch phrase");
    pydict_print(dct);
    pydict_put(dct, "z", "W");
    pydict_print(dct);
    pydict_put(dct, "y", "B");
    pydict_put(dct, "c", "C");
    pydict_put(dct, "a", "D");
    pydict_print(dct);
    printf("Length =%d\n",pydict_len(dct));

    printf("z=%s\n", pydict_get(dct, "z"));
    printf("x=%s\n", pydict_get(dct, "x"));

    printf("\nDump\n");
    for(cur = dct->head; cur != NULL ; cur = cur->next ) {
        printf("%s=%s\n", cur->key, cur->value);
    }

    pydict_del(dct);
}

/* print(dct) */
/* {'z': 'W', 'y': 'B', 'c': 'C', 'a': 'D'} */
void pydict_print(struct pydict* self)
{
    int i;
    struct dnode *cur;
    printf("{");

    // Loop until current pointer reaches NULL, or end of dict
    for ( i=0, cur = self->head; cur != NULL; cur = cur->next, i++ ) {
        printf("'%s': '%s'", cur->key, cur->value);
        // Place commas only between dict entries
        if ( i < self->count-1 ) {
            printf(", ");
        }
    }
    printf("}\n");
}

int pydict_len(const struct pydict* self)
{
    return self->count;
}

/* find a node - used in get and put */
struct dnode* pydict_find(struct pydict* self, char *key)
{
    struct dnode *cur;
    int i;

    // Loop until current pointer reaches NULL, or end of dict
    for( i=0, cur = self->head; cur != NULL; cur = cur->next, i++ ) {
        // Check if the current node contains the target key,
        // if key found, return the current node
        if ( strcmp(cur->key, key) == 0 ) {
            return cur;
        }
    }

    // If loop finishes without finding the target key, return NULL
    return NULL;
}

/* x.get(key) - Returns NULL if not found */
char* pydict_get(struct pydict* self, char *key)
{
    struct dnode *entry = pydict_find(self, key);

    // If key is present in dict then return value, else return NULL
    if ( entry != NULL ) {
        return entry->value;
    }
    else {
        return NULL; 
    }
}

/* x[key] = value; Insert or replace the value associated with a key */
void pydict_put(struct pydict* self, char *key, char *value)
{
    struct dnode *old = pydict_find(self, key);
  
    // If old key found then replace the value
    if ( old != NULL ) {
        // Allocate space for new savevalue variable
        char *savevalue = (char *) malloc(strlen(value)+1);
      
        // Check if allocation failed 
        if ( savevalue == NULL ) {
            return;
        }
       
        // Copy new value to savevalue
        strcpy(savevalue, value);
        
        // Free the data in the old value if allocation was successful
        free(old->value);
      
        // Assign to node
        old->value = savevalue;
    }
  
    // If old key not found then insert key and value
    else {
        // Allocate space for savekey and savevalue variables
        char *savekey = (char *) malloc(strlen(key)+1);
        char *savevalue = (char *) malloc(strlen(value)+1);

        // Allocate space for new node
        struct dnode *new = (struct dnode *)
            malloc(sizeof(struct dnode));
  
        // Check if allocation failed 
        if ( savekey == NULL ) {
            return;
        }
        if ( savevalue == NULL ) {
            free(savekey);
            return;
        }
        if ( new == NULL ) {
            free(savekey);
            free(savevalue);
            return;
        }

        // Copy key to savekey and value to savevalue
        strcpy(savekey, key);
        strcpy(savevalue, value);
  
        // Set new node properties
        new->key = savekey;
        new->value = savevalue;
        new->next = NULL;
  
        // Dict is empty: The new node is the head
        if ( self->head == NULL ) {
            self->head = new;
        }
        // Dict not empty: Link the old tail to the new node
        else {
           self->tail->next = new;
        }
  
        // Update the dict's tail
        self->tail = new;
  
        // Increment the counter
        self->count++;
    }
}

Input:
N/A

Output:
{'z': 'Catch phrase'}
{'z': 'W'}
{'z': 'W', 'y': 'B', 'c': 'C', 'a': 'D'}
Length =4
z=W
x=(null)

Dump
z=W
y=B
c=C
a=D

Notes:
- I ended up reusing a lot of the code I had created in a past problem that involved creating functions that
  mimic a python list.
- For the pydict_print() function, the changes I made to existing code were renaming the struct datatype to
  dnode to denote a dictionary node, printing two strings separated by a colon and space, assigning the 
  current pointer to point to a key and value variable found in the struct dnode for printing the strings, 
  and printing curly braces instead of brackets. The function entailed declaring variables, using a for loop
  to loop through a dictionary with pointers and printing the corresponding key and value pairs, placing
  commas between dict entries using an if statement, and matching the format of a python dictionary using
  printf statements.
- The pydict_len() function was a matter of using a pointer to a variable named count that was assigned in 
  the struct pydict.
- The pydict_find() function was similar to the pydict_print() function in terms of declared variables and
  the for loop but the expressions in the for loop were different. These conditions chcecked if the current
  node contained the target key and if the key was found then the current node was returned. If the loop
  finished without finding the target key then the function returned NULL.
- The pydict_get() function called an existing function pydict_find() and assigned it to a pointer variable
  called entry in the struct dnode. If the key found in the function pydict_find() was present in the
  dictionary then the value was returned using a pointer that points from entry to the variable value in the
  struct dnode, otherwise the function returned NULL.
- The pydict_put() function inserted or replaced the value associated with a key based on if and else
  statements where a key had existed in the dictionary or not. This function called upon the
  pydict_find() function and assigned the results to a variable called old in the struct dnode. For the if
  condition, if the old key was found then the old value was replaced. The data in the old value was freed 
  before allocating and setting the new value to the existing key. In the else condition, if the old key
  was not found then the key and value was inserted into the dictionary. Separate variables were declared
  to allocate space for the key and value being inserted. A new node was declared, allocated in the
  struct dnode, and set with properties using pointers. An if/else statement was created to determine 
  whether the dictionary was empty or not so that the new node would point to the head or the new node
  would link to the old tail respectively. At the end of the else condition, the dictionary's tail
  was updated to the new node and a counter was incremented.

Suggestions and Final Thoughts:
- In the pydict_put() function, I was missing the assignment of the node where the old variable pointing to
  the value would be changed to the newly allocated savevalue variable.
  ex.
      old->value = savevalue;
- To prevent a memory leak, it is best to have functions that clean up after themselves if any step of
  their processes fails. The free() function can be used in the if conditions that check if the allocation
  failed or not. If a successful allocation occurs then the free conditions can take place.
  ex.
      if (savevalue == NULL) {
          free(savekey);          // Clean up the key before leaving!
          return;
      }
      if (new_node == NULL) {
          free(savekey);          // Clean up everything 
          free(savevalue);        // Clean up everything
          return;
  ex.
      if ( old != NULL ) {
          char *savevalue = malloc(strlen(value) + 1);
          if (savevalue == NULL) {
              return;
          }
          strcpy(savevalue, value)
          free(old->value);               // Free AFTER successful malloc
          old->value = savevalue;
      }
- For the else block of the pydict_put() function, I refactored the code to group the declarations and 
  allocation first and then placed the checks for allocation failures with free() functions before performing
  any actions such as strcpy() or assigning properties.
  ex.
      // Allocate space for savekey and savevalue variables
      char *savekey = (char *) malloc(strlen(key)+1);
      char *savevalue = (char *) malloc(strlen(value)+1);

      // Allocate space for new node
      struct dnode *new = (struct dnode *)
          malloc(sizeof(struct dnode));
  
      // Check if allocation failed 
      if ( savekey == NULL ) {
          return;
      }
      if ( savevalue == NULL ) {
          free(savekey);
          return;
      }
      if ( new == NULL ) {
          free(savekey);
          free(savevalue);
          return;
      }

      // Copy key to savekey and value to savevalue
      strcpy(savekey, key);
      strcpy(savevalue, value);
- Checking for allocations failing code can be simplified.
  ex.
      if ( !savekey || !savevalue || !new ) {
          free(savekey);
          free(savevalue);
          free(new);
          return;
      }

############################################################################################################

Source:

Question:

Python Code:

C Code:

Input:

Output:

Notes:

Suggestions and Final Thoughts:

############################################################################################################

Source:

Question:

Python Code:

C Code:

Input:

Output:

Notes:

Suggestions and Final Thoughts:

############################################################################################################

Source:

Question:

Python Code:

C Code:

Input:

Output:

Notes:

Suggestions and Final Thoughts:

############################################################################################################
