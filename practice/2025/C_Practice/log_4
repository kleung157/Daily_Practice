C Practice Exercises

############################################################################################################

Source:
C Programming for Everybody - Implement a Python str class

Question:
You will a set of supporting functions using the following structure to implement a subset of the Python str class in C. 
Some code and method signatures have been provided for you as well as a main() program and some support routines from the lecture slides. 
In the constructor, you will allocate a 10 character buffer. 
If as data is added, it exceeds the length of the buffer use realloc() to expand the buffer by 10. T
here is a good deal of discussion of this application in the lecture materials associated with this assignment.

Python Code:
x = str()
x = x + 'H'
print(x)
x = x + 'ello world'
print(x)
x = 'A completely new string'
print("String = ", x)
print("Length = ", len(x))

C Code:
**Attempt #1
#include <string.h>
/* x = x + 'h'; */

void pystr_append(struct pystr* self, char ch) {
    /* Need about 10 lines of code here */
    self->data[self->length] = self->data[self->length] + ch;
    self->length++;
    if ( self->length >= (self->alloc - 2) ) {
        self->alloc = self->alloc + 10;
        self->data = (char *)
            realloc(self->data, self->alloc);
    }
}

/* x = x + "hello"; */

void pystr_appends(struct pystr* self, char *str) {
    /* Need a line or two of code here */
    int alloc = self->alloc;
    for (self->length=0; self->length <= alloc; ) {
         pystr_append(self, str[self->length-1]);
    }
}

/* x = "hello"; */

void pystr_assign(struct pystr* self, char *str) {
    /* Need about three lines of code here */
    self->data[0] = '\0';
    self->alloc = 22;
    pystr_appends(self, str);
    strcpy(self->data, str);
}


** Solution #1
#include <stdio.h>
#include <stdlib.h>

struct pystr
{
    int length;
    int alloc; /* the length of *data */
    char *data;
};

/* Constructor - x = str() */
struct pystr * pystr_new() {
    struct pystr *p = malloc(sizeof(*p));
    p->length = 0;
    p->alloc = 10;
    p->data = malloc(10);
    p->data[0] = '\0';
    return p;
}

/* Destructor - del(x) */
void pystr_del(const struct pystr* self) {
    free((void *)self->data); /* free string first */
    free((void *)self);
}

void pystr_dump(const struct pystr* self)
{
    printf("Pystr length=%d alloc=%d data=%s\n",
            self->length, self->alloc, self->data);
}

int pystr_len(const struct pystr* self)
{
    return self->length;
}

char *pystr_str(const struct pystr* self)
{
    return self->data;
}

int main(void)
{
    setvbuf(stdout, NULL, _IONBF, 0);  /* Internal */

    struct pystr * x = pystr_new();
    pystr_dump(x);

    pystr_append(x, 'H');
    pystr_dump(x);

    pystr_appends(x, "ello world");
    pystr_dump(x);

    pystr_assign(x, "A completely new string");
    printf("String = %s\n", pystr_str(x));
    printf("Length = %d\n", pystr_len(x));
    pystr_del(x);
}

/* x = x + 'h'; */

void pystr_append(struct pystr* self, char ch) {
    // Check if reallocation is needed
    if ( self->length + 1 >= self->alloc ) {
        self->alloc = self->alloc + 10;
        self->data = (char *)
            realloc(self->data, self->alloc);
    }
    // Append the character
    self->data[self->length] = ch; 
    // Increment the length
    self->length++;
    // Ensure string is null-terminated
    self->data[self->length] = '\0';
}

/* x = x + "hello"; */

void pystr_appends(struct pystr* self, char *str) {
    int i;
    // Iterate through the string using a counter
    for (i=0; str[i] != '\0'; i++) {
         pystr_append(self, str[i]);
    }
}

/* x = "hello"; */

void pystr_assign(struct pystr* self, char *str) {
    // Clear existing string and reset length
    self->data[0] = '\0';
    self->length = 0;
    // Copy the new string
    pystr_appends(self, str);
}

Input:
N/A

Output:
Pystr length=0 alloc=10 data=
Pystr length=1 alloc=10 data=H
Pystr length=11 alloc=20 data=Hello world
String = A completely new string
Length = 23

Notes:
- The lecture provided the code for increasing the allocation. If the length started to exceed the allocation
  then the realloc() function was used to add 10 more to the allocated memory amount. I used that to initially
  start writing the pystar_append() function. The pystar_append() function involved using numerous pointers 
  and incrementing. 
- For the pystr_appends() function, I used a for loop and had to make sure the alloc was an integer and 
  assigned to a variable or else the for loop condition would not recognize self->alloc as the value 10. 
  Only when I assigned int alloc = self->alloc did it recognize it as 10. This for loop also ran the 
  pystr_append() function repeatedly to affix the string to the variable. 
- The pystar_assign() was a lot trickier and I couldn't quite figure out how to do it without using the 
  string.h library and the dedicated strcpy() function. My end result was assigning the self->data to the 
  null terminator '\0' then reallocating manually for the allocation to the string size. After that, I called
  the pystr_appends() function and finally the strcpy() function. When I used pystr_dump() in the
  pystr_assign() function to check the printed length, alloc and data it had extra allocation by 2 and the
  allocation assignment that I needed for self->alloc was off by 1. Tried a while to look through the code
  and troubleshoot but couldn't quite figure out what was causing this discrepancy.

Suggestions and Final Thoughts:
- In the if statement for checking if reallocation is needed, another way to check if the new length will
   meet or exceed the allocation size is to use "if (self-> length + 1 >= self->alloc)".
- Rather than performing arithmetic for assigning the appending of characters in the line
  "self->data[self->length] = self->data[self->length] + ch;", it is best to just assign the character to
  the variable using "self->data[self->length] = ch;". 
- When strings are modified, it is best to ensure the string is null-terminated using '\0' as in the line
  "self->data[self->length] = '\0'
- Initially, I created a for loop by using an initializer integer variable i but for some reason had tried
  to incorporate the self->length variable into the for loop which ended up being too complicated. Sticking
  with the variable i ensures there's no mix up in the function itself. The for loop ended up being a 
  traversal through a string until the end of the string itself, or the null terminator and incremented each
  time. It also called the pystr_append() function multiple times to carry out the appending operation.
- For the pystr_assign() function, I had the correct logic when I made my first few attempts but my
  pystr_appends() and pystr_append() functions did not correspond correctly so it would throw off the 
  final result. I did use the null terminator for self->data[0] and self->length = 0 along with calling the
  pystr_appends() function within pystr_assign() function.
- Seems like overall, I made the problem a little more difficult than I needed to by trying to incorporate
  all the pointers that I could but some functions didn't need to have the pointers. Still was good practice
  and challenge in the end.

############################################################################################################

Source:
C Programming for Everybody - Implement a Python list class

Question:
You will a set of supporting functions using the following structures to implement a subset of the Python list class in C. 
Some code and method signatures have been provided for you as well as a main() program and some support routines from the lecture slides. 
There is a good deal of discussion of this application in the lecture materials associated with this assignment.

Python Code:
lst = list();
lst.append("Hello world");
print(lst)
lst.append("Catch phrase");
print(lst)
lst.append("Brian");
print(lst)
print("Length =", len(lst);

print("Brian?", lst.index("Brian"));

if "Bob" in lst:
    print("Bob?", lst.index("Bob"));
else:
    print("Bob? 404");

C Code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct lnode {
    char *text;
    struct lnode *next;
};

struct pylist {
  struct lnode *head;
  struct lnode *tail;
  int count;
};

/* Constructor - lst = list() */
struct pylist * pylist_new() {
    struct pylist *p = malloc(sizeof(*p));
    p->head = NULL;
    p->tail = NULL;
    p->count = 0;
    return p;
}

/* Destructor - del(lst) */
void pylist_del(struct pylist* self) {
    struct lnode *cur, *next;
    cur = self->head;
    while(cur) {
        free(cur->text);
        next = cur->next;
        free(cur);
        cur = next;
    }
    free((void *)self);
}

int main(void)
{
    setvbuf(stdout, NULL, _IONBF, 0);  /* Internal */

    struct pylist * lst = pylist_new();
    pylist_append(lst, "Hello world");
    pylist_print(lst);
    pylist_append(lst, "Catch phrase");
    pylist_print(lst);
    pylist_append(lst, "Brian");
    pylist_print(lst);
    printf("Length = %d\n", pylist_len(lst));
    printf("Brian? %d\n", pylist_index(lst, "Brian"));
    printf("Bob? %d\n", pylist_index(lst, "Bob"));
    pylist_del(lst);
}

/* print(lst) */
void pylist_print(struct pylist* self)
{
    int i;
    struct lnode *cur;
    printf("[");
    /* Loop until the current pointer reaches NULL, 
    NULL signifies end of list */
    for(i=0, cur=self->head; cur != NULL; cur=cur->next, i++) { 
        printf("'%s'", cur->text);
        /* Place commas only between list entries */
        if ( i < self->count-1 ) {
            printf(", ");
        }
    }
    printf("]\n");
}

/* len(lst) */
int pylist_len(const struct pylist* self)
{
    return self->count;
}

/* lst.append("Hello world") */
void pylist_append(struct pylist* self, char *str) {
    /* Allocate space for save variable
       Copy string to "save"
       increment count by 1 */
    char *save = (char *) malloc(strlen(str)+1);
    strcpy(save, str);
    self->count++;
  
    /* Allocate space only for the new node */
    struct lnode *new = (struct lnode *)
        malloc(sizeof(struct lnode));
 
    /* Check if allocation failed */
    if ( new == NULL ) {
        return;
    }
  
    /* List is not empty.
       Append new node by updating current tail's 'next' pointer.
       Update the list's 'tail' pointer to be the new node. */
    if ( self->tail != NULL ) {
        self->tail->next = new;
        new->text = save;
        new->next = NULL;
        self->tail = new;
    }
   
    /* List is empty. 
       Head and tail point to the new node */
    if ( self->head == NULL ) {
        new->text = save;
        self->head = new;
        self->tail = new;
    }    
}

/* lst.index("Hello world") - if not found -1 */
int pylist_index(struct pylist* self, char *str)
{
    struct lnode *cur;
    int i;
    /* Loop until the current pointer reaches NULL, 
       NULL signifies end of list */
    for(i=0, cur=self->head; cur != NULL; cur=cur->next, i++) {
        /* Check if the current node contains the target value
           If value found, return the index */
        if ( strcmp(cur->text, str) == 0 ) {
            return i;
        }
    }
    /* If the loop finishes without finding the value, return -1*/
    return -1;
}

Input:
N/A

Output:
['Hello world']
['Hello world', 'Catch phrase']
['Hello world', 'Catch phrase', 'Brian']
Length = 3
Brian? 2
Bob? -1

Notes:
- I started this problem with working on the pylist.append() function first. As the lecture had hinted, one
  of the chapter 6 problems that I had done on linked lists had the code necessary to create this function.
  The modifications made were to allocate space for a save variable, copy the string to save and increment
  the list count by 1 each time it was called. Also, since this was a character string instead of a integer
  value, I had to change some of the pointer values to 'save' for situations where if the list was or was not
  empty such as with "new->text = save;"
- The pylist_len() function was straightforward, since I incremented the self->count each time I called
  pylist_append(), it was a matter of returning "self->count" to get the length of the list. 
- The next function I worked on was the pylist_print(), this was pretty tricky as it was like another
  problem I was working on before where I didn't use a counter variable and tried to use a pointer variable. 
  It helped tremendously to use i as a counter variable. Once I created a for loop to traverse a list, it was 
  a matter of where to put each individual printf() function to simulate the Python list output like [ , , ]. 
  The trickiest part was how to get the commas to be within entries and not on the outsides of entries. That's
  where the i counter variable really helped.
- The pylist_index() function was another function that was used before in Chapter 6 problems for scanning
  through a list. I took my existing for loop from the pylist_print() function and added a conditional if
  statement that compared the pointer values to the string being called using the strcmp() function. If the
  strings were the same then it would be 0, and the index i was returned when calling the function. If there
  was not a match after the loop finished then the function returned -1.

Suggestions and Final Thoughts:
- The lines "new->text = save;" and "new->next = NULL;" can be placed outside of the if statements for the
  lists being empty or not. It sets the new node's peropeties and prevents duplication.
- The conditional statements could be unified using if/else instead of two if statements since they both
  deal with NULL situations.
  ex.
      if (self->head == NULL) {
          self->head = new;    // List is EMPTY: The new node is the head
      } 
      else {
          self->tail->next = new;     // List is NOT empty: Link the old tail to the new node
      }
      self->tail = new;         // Update the list's tail 
- There is a check to see if allocation failed for new. There should also be one for save as well.
  ex. 
      if (save == NULL) { 
          return 
      }

############################################################################################################

Source:

Question:

Python Code:

C Code:

Input:

Output:

Notes:

############################################################################################################

Source:

Question:

Python Code:

C Code:

Input:

Output:

Notes:

############################################################################################################
