Date: 10/21/2025

############################

Website:
StrataScratch - ID 2102

Difficulty:
Medium

Question Type:
R

Question:
Netflix - Flags per Video
For each video, find how many unique users flagged it. A unique user can be identified using the combination of their first name and last name. 
Do not consider rows in which there is no flag ID.

Data Dictionary:
Table name = 'user_flags'
user_firstname: character (str)
user_lastname: character (str)
video_id: character (str)
flag_id: character (str)

Code:
Solution #1
## Question:
# For each video find how many unique users flagged it.
# A unique user can be identified using the combination of their first and last name.
# Do not consider rows in which there is no flag ID.

## Output:
# video_id, unique_user_count

## Import libraries:
#install.packages(tidyverse)
library(tidyverse)

## Load and preview data:
#user_flags <- read_csv('user_flags.csv')
flags_df <- data.frame(user_flags)
head(flags_df, 5)

## Check datatypes, nulls, and rows:
# Nulls - user_firstname(3), user_lastname(3), video_id(1), flag_id(4)
# Rows - 29
data.frame(lapply(flags_df, class))
colSums(is.na(flags_df))
nrow(flags_df)

## Iteration:
result_df <- flags_df %>%
    filter(
        # 1. Filter rows where flag_id is not null
        !is.na(flag_id)
    ) %>%
    mutate(
        # 2. Clean user_firstname and user_lastname columns by replacing nulls with ''
        user_firstname_cleaned = case_when(
            is.na(user_firstname) ~ '',
            TRUE ~ user_firstname
        ),
        user_lastname_cleaned = case_when(
            is.na(user_lastname) ~ '',
            TRUE ~ user_lastname
        ),
        # 3. Create unique user name with first and last name using string concatenation
        # 4. Trim any excess leading/lagging white space
        unique_user_name = str_trim(str_c(user_firstname_cleaned, ' ', user_lastname_cleaned))
    ) %>%
    group_by(video_id) %>%
    summarise(
        # 5. Count the number of unique users for each video id that was flagged
        unique_user_count = n_distinct(unique_user_name),
        .groups = "drop"
    ) %>%
    arrange(video_id)

## Result:
result_df

Notes:
- Upon initial data quality checks, there were a number of null values that I took into consideration
  when beginning my approach. Filtering and replacing nulls was important to clean columns that could 
  potentially create messy values in string concatenation for a unique identifier. Couldn't quite remember
  the specific function that R has for filling nulls values so instead used a case_when() function statement.
  From there, the final step of grouping and aggregation was straightforward to obtain the solution.

Suggestions and Final Thoughts:
- If a column didn't contain nulls and instead had empty strings then adding an additional filter would
  be helpful to ensure not including certain parts of the data. In this case it was nulls and not empty strings.
  ex. 
      filter(!is.na(flag_id) & flag_id != "")
- coalesce() and replace_na() can be used as dedicated functions for filling null values
  ex.
     mutate(user_firstname_cleaned = coalesce(user_firstname, ''))

Solve Duration:
22 minutes

Notes Duration:
4 minutes

Suggestions and Final Thoughts Duration:
3 minutes

############################

Website:
StrataScratch - ID 2138

Difficulty:
Medium

Question Type:
Python

Question:
DoorDash - Top 2 Restaurants of 2022
Christmas is quickly approaching, and your team anticipates an increase in sales. 
To predict the busiest restaurants, they wanted to identify the top two restaurants by ID in terms of sales in 2022.
The output should include the restaurant IDs and their corresponding sales.
Note: Please remember that if an order has a blank value for actual_delivery_time, it has been canceled and therefore does not count towards monthly sales.

Data Dictionary:
Table name = 'order_value'
delivery_id: object (str)
sales_amount: float64 (flt)
Table name = 'delivery_orders'
delivery_id: object (str)
order_placed_time: datetime64 (dt)
predicted_delivery_time: datetime64 (dt)
actual_delivery_time: datetime64 (dt)
delivery_rating: float64 (flt)
driver_id: object (str)
restaurant_id: object (str)
consumer_id: object (str)

Code:
Solution #1
## Question:
# Christmas is quickly approaching and your team anticipates an increase in sales.
# To predict the busiest restaurants they want to identify the top two restaurants 
# by ID in terms of sales in 2022.
# The output should include the restaurant IDs and their corresponding sales.
# Please remember that if an order has a blank value for actual_delivery_time,
# it has been canceled and therefore does not count towards monthly sales.

## Output:
# restaurant_id, total_sales

## Import libraries:
import numpy as np
import pandas as pd

## Load and preview data:
#order_value = pd.read_csv("order_value.csv")
#delivery_orders = pd.read_csv("delivery_orders.csv")
value_df = pd.DataFrame(order_value) 
orders_df = pd.DataFrame(delivery_orders)
value_df.head(5)
orders_df.head(5)

## Check datatypes, nulls, and rows:
# Nulls - value: 0
#       - orders: actual_delivery_time(3), delivery_rating(3)
# Rows - value: 50
#      - orders: 50
#value_df.info()
#value_df.isna().sum()
#orders_df.info()
#orders_df.isna().sum()

## Iteration:
# 1. Inner join value and order DataFrames by delivery_id
merged_df = pd.merge(value_df, orders_df, on="delivery_id", how="inner")

# 2. Filter for orders placed in 2022 and actual_delivery_time is not null
filtered_df = merged_df[
    (merged_df["order_placed_time"].dt.year == 2022) &
    (merged_df["actual_delivery_time"].notna())
].copy()

# 3. Calculate the total sales for each restaurant_id
result_df = filtered_df.groupby("restaurant_id")["sales_amount"].sum().reset_index(name="total_sales")

# 4. Rank the restaurants by total_sales in DESC order, include ties
result_df["rank"] = result_df["total_sales"].rank(method="dense", ascending=False)

# 5. Filter for top two ranking restaurants in terms of highest sales
result_df = result_df[
    result_df["rank"] <= 2    
]

# 6. Select relevant columns and sort by total sales in DESC order
result_df = result_df[["restaurant_id", "total_sales"]].sort_values(by="total_sales", ascending=False)

## Result:
print("Top two restaurants by ID in terms of sales in 2022:")
result_df

Notes:
- The question involved joining, filtering, grouping and aggregation, ranking, filtering, selecting and then
  sorting to arrive to the final answer. To see the complete data, an inner join was necessary since there
  were 50 rows for each provided DataFrame to match one another. Filtering out null values in the 
  actual_delivery_time column and dates not in 2022 in order_placed_time column was important to ensure the
  grouping aggregation was correct and ranking could be achieved properly. 

Suggestions and Final Thoughts:
- If any of the time columns were string object datatypes and not in the correct format of datetime then it
  would be necessary to convert them from strings to datetime using pd.to_datetime() function before
  performing the initial inner join. In this case, time columns were defined already as datetime. 
  ex. 
      orders_df["order_placed_time"] = pd.to_datetime(orders_df["order_placed_time"])
      orders_df["actual_delivery_time"] = pd.to_datetime(orders_df["actual_delivery_time"])
- The question didn't say whether to include ties but anytime that I see a question asking for top rankings, 
  it makes sense to use dense rank to account for ties 

Solve Duration:
15 minutes

Notes Duration:
4 minutes

Suggestions and Final Thoughts Duration:
4 minutes

############################

Website:
StrataScratch - ID 9952

Difficulty:
Hard

Question Type:
SQL

Question:
ESPN - Name to Medal Connection
Find the connection between the number of letters in the athlete's first name and the number of medals won for each type for medal, including no medals. 
Output the length of the name along with the corresponding number of no medals, bronze medals, silver medals, and gold medals.

Data Dictionary:
Table name = 'olympics_athletes_events'
age: double precision (dbl)
city: text (str)
event: text (str)
games: text (str)
height: double precision (dbl)
id: bigint (int)
medal: text (str)
name: text (str)
noc: text (str)
season: text (str)
sex: text (str)
sport: text (str)
team: text (str)
weight: double precision (dbl)
year: bigint (int)

Code:
Solution #1
-- Question:
-- Find the connection between the letters in the athlete's first name 
-- and the number of medals won for each type for medal, including no medals.
-- Output the length of the name along with the corresponding number of no medals, bronze medals,
-- silver medals, and gold medals.

-- Output:
-- name_length, no_medals, bronze_medals, silver_medals, gold_medals

-- Preview data:
SELECT * FROM olympics_athletes_events LIMIT 5;

-- Check nulls and rows:
-- Nulls - age(65), height(226), medal(232), weight(249))
-- Rows - 352
SELECT
    SUM(CASE WHEN age IS NULL THEN 1 ELSE 0 END) AS col1,
    SUM(CASE WHEN city IS NULL THEN 1 ELSE 0 END) AS col2,
    SUM(CASE WHEN event IS NULL THEN 1 ELSE 0 END) AS col3,
    SUM(CASE WHEN games IS NULL THEN 1 ELSE 0 END) AS col4,
    SUM(CASE WHEN height IS NULL THEN 1 ELSE 0 END) AS col5,
    SUM(CASE WHEN id IS NULL THEN 1 ELSE 0 END) AS col6,
    SUM(CASE WHEN medal IS NULL THEN 1 ELSE 0 END) AS col7,
    SUM(CASE WHEN name IS NULL THEN 1 ELSE 0 END) AS col8,
    SUM(CASE WHEN noc IS NULL THEN 1 ELSE 0 END) AS col9,
    SUM(CASE WHEN season IS NULL THEN 1 ELSE 0 END) AS col10,
    SUM(CASE WHEN sex IS NULL THEN 1 ELSE 0 END) AS col11,
    SUM(CASE WHEN sport IS NULL THEN 1 ELSE 0 END) AS col12,
    SUM(CASE WHEN team IS NULL THEN 1 ELSE 0 END) AS col13,
    SUM(CASE WHEN weight IS NULL THEN 1 ELSE 0 END) AS col14,
    SUM(CASE WHEN year IS NULL THEN 1 ELSE 0 END) AS col15,
    COUNT(*) AS total_rows
FROM olympics_athletes_events;

-- Iteration:
-- Find the connection between the letters in the athlete's first name 
-- and the number of medals won for each type for medal, including no medals.
-- Output the length of the name along with the corresponding number of no medals, bronze medals,
-- silver medals, and gold medals.
-- name_length, no_medals, bronze_medals, silver_medals, gold_medals
-- 1. Replace any delimiters with '' and trim leading/lagging white spaces in name
-- 2. IF the full name does not contain any spaces in between names 
--    and the string position function returns 0,
--    THEN output the length of the name, 
--    ELSE find the position of the first instance of a blank space ' ' then substract it by 1 
-- 3. Sum the number of instances for each medal category for each name_length 
WITH CleanNamesMedals AS (
    SELECT 
        TRIM(REPLACE(REPLACE(name, ',', ''), '.', '')) AS clean_name,
        medal
    FROM olympics_athletes_events
)
SELECT 
    CASE WHEN STRPOS(clean_name, ' ') = 0 
        THEN LENGTH(clean_name)
        ELSE STRPOS(clean_name, ' ') - 1
    END as name_length,
    SUM(CASE WHEN medal IS NULL THEN 1 ELSE 0 END) AS no_medals,
    SUM(CASE WHEN medal = 'Bronze' THEN 1 ELSE 0 END) AS bronze_medals,
    SUM(CASE WHEN medal = 'Silver' THEN 1 ELSE 0 END) AS silver_medals,
    SUM(CASE WHEN medal = 'Gold' THEN 1 ELSE 0 END) AS gold_medals
FROM CleanNamesMedals
GROUP BY name_length
ORDER BY name_length;

-- Result:
WITH CleanNamesMedals AS (
    SELECT 
        TRIM(
            REPLACE( -- 1. Replace any delimiters with '' and trim leading/lagging white spaces in name
                REPLACE(name, ',', '')
            , '.', '')
        ) AS clean_name,
        medal
    FROM 
        olympics_athletes_events
)
SELECT 
    CASE                                 -- 2. IF the full name does not contain any spaces in between names
        WHEN STRPOS(clean_name, ' ') = 0 -- and the string position function returns 0,
        THEN LENGTH(clean_name)          -- THEN output the length of the name, 
        ELSE STRPOS(clean_name, ' ') - 1 -- ELSE find the position of the first instance of a blank space ' '
    END AS name_length,                  -- then substract it by 1 
    SUM( -- 3. Sum the number of instances for each medal category for each name_length
        CASE 
            WHEN medal IS NULL 
            THEN 1 
            ELSE 0 
        END
    ) AS no_medals, 
    SUM(
        CASE 
            WHEN medal = 'Bronze' 
            THEN 1 
            ELSE 0 
        END
    ) AS bronze_medals,
    SUM(
        CASE 
            WHEN medal = 'Silver'
            THEN 1 
            ELSE 0 
        END
    ) AS silver_medals,
    SUM(
        CASE 
            WHEN medal = 'Gold' 
            THEN 1 
            ELSE 0 
        END
    ) AS gold_medals
FROM 
    CleanNamesMedals
GROUP BY 
    name_length
ORDER BY 
    name_length;

Notes:
- The name column being a text datatype had a full name for each row and needed to be cleaned correctly before
  extracting the length of the first name and aggregating that with the counts of each medal category instance.
  Initially I used the LENGTH() function to see if the length of the names matched their first name length but
  there were a number of instances where some names were not just first name but their full name, names were 
  abbreviated with a single letter then ., and names may have contained leading/lagging white spaces.
- Once I replaced any possible delimiters with empty strings '' and trimmed the excess outer spaces, I used the
  STRPOS() function to find the position of the first instance of blank spaces ' ' in between the names of each
  full name. There was another problem that occured when using this function where if a name did not contain any
  blank spaces then it would default to 0 meaning names only had their first name and not the full name. Which
  meant that I had to produce a case statement to solve the instances for this situation. The case statement
  produced the length of the first name if the string position was 0 for the first instance of a blank space
  and all other cases the str position for the first instance of a blank space was susbtracted by 1 to get the
  length of the first name from the full name.
- After finishing text manipulation, case statements were used to count instances of each medal category then
  a SUM aggregation was performed to create separate columns for each name_length. 
- Spent a considerable amount of time making sure the code was formatted and space correctly for readability. 

Suggestions and Final Thoughts:
- Could not remember the function for finding the position of a string index so had to reference documentation
  for PostgreSQL specific functions. In this problem, I used STRPOS().
  PostgresSQL - STRPOS(), POSITION() CHARINDEX()
  MYSQL - INSTR(), LOCATE()
  Oracle - INSTR()
  SQLite - INSTR()
- Text manipulation can be a bit tedious but can be fun to solve as it is a very detail oriented process.
  My recent Excel courses have drilled a lot of the text manipulation steps in my head to ensure clean data.
  Certainly has been a while since I encountered a 'Hard' SQL problem that has actually reflected it's difficulty.

Solve Duration:
60 minutes

Notes Duration:
10 minutes

Suggestions and Final Thoughts Duration:
7 minutes

############################
