C Practice Exercises

############################################################################################################

Source:
C Programming for Everybody - Implement a Python str class

Question:
You will a set of supporting functions using the following structure to implement a subset of the Python str class in C. 
Some code and method signatures have been provided for you as well as a main() program and some support routines from the lecture slides. 
In the constructor, you will allocate a 10 character buffer. 
If as data is added, it exceeds the length of the buffer use realloc() to expand the buffer by 10. T
here is a good deal of discussion of this application in the lecture materials associated with this assignment.

Python Code:
x = str()
x = x + 'H'
print(x)
x = x + 'ello world'
print(x)
x = 'A completely new string'
print("String = ", x)
print("Length = ", len(x))

C Code:
**Attempt #1
#include <string.h>
/* x = x + 'h'; */

void pystr_append(struct pystr* self, char ch) {
    /* Need about 10 lines of code here */
    self->data[self->length] = self->data[self->length] + ch;
    self->length++;
    if ( self->length >= (self->alloc - 2) ) {
        self->alloc = self->alloc + 10;
        self->data = (char *)
            realloc(self->data, self->alloc);
    }
}

/* x = x + "hello"; */

void pystr_appends(struct pystr* self, char *str) {
    /* Need a line or two of code here */
    int alloc = self->alloc;
    for (self->length=0; self->length <= alloc; ) {
         pystr_append(self, str[self->length-1]);
    }
}

/* x = "hello"; */

void pystr_assign(struct pystr* self, char *str) {
    /* Need about three lines of code here */
    self->data[0] = '\0';
    self->alloc = 22;
    pystr_appends(self, str);
    strcpy(self->data, str);
}


** Solution #1
#include <stdio.h>
#include <stdlib.h>

struct pystr
{
    int length;
    int alloc; /* the length of *data */
    char *data;
};

/* Constructor - x = str() */
struct pystr * pystr_new() {
    struct pystr *p = malloc(sizeof(*p));
    p->length = 0;
    p->alloc = 10;
    p->data = malloc(10);
    p->data[0] = '\0';
    return p;
}

/* Destructor - del(x) */
void pystr_del(const struct pystr* self) {
    free((void *)self->data); /* free string first */
    free((void *)self);
}

void pystr_dump(const struct pystr* self)
{
    printf("Pystr length=%d alloc=%d data=%s\n",
            self->length, self->alloc, self->data);
}

int pystr_len(const struct pystr* self)
{
    return self->length;
}

char *pystr_str(const struct pystr* self)
{
    return self->data;
}

int main(void)
{
    setvbuf(stdout, NULL, _IONBF, 0);  /* Internal */

    struct pystr * x = pystr_new();
    pystr_dump(x);

    pystr_append(x, 'H');
    pystr_dump(x);

    pystr_appends(x, "ello world");
    pystr_dump(x);

    pystr_assign(x, "A completely new string");
    printf("String = %s\n", pystr_str(x));
    printf("Length = %d\n", pystr_len(x));
    pystr_del(x);
}

/* x = x + 'h'; */

void pystr_append(struct pystr* self, char ch) {
    // Check if reallocation is needed
    if ( self->length + 1 >= self->alloc ) {
        self->alloc = self->alloc + 10;
        self->data = (char *)
            realloc(self->data, self->alloc);
    }
    // Append the character
    self->data[self->length] = ch; 
    // Increment the length
    self->length++;
    // Ensure string is null-terminated
    self->data[self->length] = '\0';
}

/* x = x + "hello"; */

void pystr_appends(struct pystr* self, char *str) {
    int i;
    // Iterate through the string using a counter
    for (i=0; str[i] != '\0'; i++) {
         pystr_append(self, str[i]);
    }
}

/* x = "hello"; */

void pystr_assign(struct pystr* self, char *str) {
    // Clear existing string and reset length
    self->data[0] = '\0';
    self->length = 0;
    // Copy the new string
    pystr_appends(self, str);
}

Input:
N/A

Output:
Pystr length=0 alloc=10 data=
Pystr length=1 alloc=10 data=H
Pystr length=11 alloc=20 data=Hello world
String = A completely new string
Length = 23

Notes:
- The lecture provided the code for increasing the allocation. If the length started to exceed the allocation
  then the realloc() function was used to add 10 more to the allocated memory amount. I used that to initially
  start writing the pystar_append() function. The pystar_append() function involved using numerous pointers 
  and incrementing. 
- For the pystr_appends() function, I used a for loop and had to make sure the alloc was an integer and 
  assigned to a variable or else the for loop condition would not recognize self->alloc as the value 10. 
  Only when I assigned int alloc = self->alloc did it recognize it as 10. This for loop also ran the 
  pystr_append() function repeatedly to affix the string to the variable. 
- The pystar_assign() was a lot trickier and I couldn't quite figure out how to do it without using the 
  string.h library and the dedicated strcpy() function. My end result was assigning the self->data to the 
  null terminator '\0' then reallocating manually for the allocation to the string size. After that, I called
  the pystr_appends() function and finally the strcpy() function. When I used pystr_dump() in the
  pystr_assign() function to check the printed length, alloc and data it had extra allocation by 2 and the
  allocation assignment that I needed for self->alloc was off by 1. Tried a while to look through the code
  and troubleshoot but couldn't quite figure out what was causing this discrepancy.

Suggestions and Final Thoughts:
- In the if statement for checking if reallocation is needed, another way to check if the new length will
   meet or exceed the allocation size is to use "if (self-> length + 1 >= self->alloc)".
- Rather than performing arithmetic for assigning the appending of characters in the line
  "self->data[self->length] = self->data[self->length] + ch;", it is best to just assign the character to
  the variable using "self->data[self->length] = ch;". 
- When strings are modified, it is best to ensure the string is null-terminated using '\0' as in the line
  "self->data[self->length] = '\0'
- Initially, I created a for loop by using an initializer integer variable i but for some reason had tried
  to incorporate the self->length variable into the for loop which ended up being too complicated. Sticking
  with the variable i ensures there's no mix up in the function itself. The for loop ended up being a 
  traversal through a string until the end of the string itself, or the null terminator and incremented each
  time. It also called the pystr_append() function multiple times to carry out the appending operation.
- For the pystr_assign() function, I had the correct logic when I made my first few attempts but my
  pystr_appends() and pystr_append() functions did not correspond correctly so it would throw off the 
  final result. I did use the null terminator for self->data[0] and self->length = 0 along with calling the
  pystr_appends() function within pystr_assign() function.
- Seems like overall, I made the problem a little more difficult than I needed to by trying to incorporate
  all the pointers that I could but some functions didn't need to have the pointers. Still was good practice
  and challenge in the end.

############################################################################################################

Source:

Question:

Python Code:

C Code:

Input:

Output:

Notes:

############################################################################################################

Source:

Question:

Python Code:

C Code:

Input:

Output:

Notes:

############################################################################################################

Source:

Question:

Python Code:

C Code:

Input:

Output:

Notes:

############################################################################################################
