C Practice Exercises

############################################################################################################

Source:
C Programming for Everybody - Implement a Python str class

Question:
You will a set of supporting functions using the following structure to implement a subset of the Python str class in C. 
Some code and method signatures have been provided for you as well as a main() program and some support routines from the lecture slides. 
In the constructor, you will allocate a 10 character buffer. 
If as data is added, it exceeds the length of the buffer use realloc() to expand the buffer by 10. T
here is a good deal of discussion of this application in the lecture materials associated with this assignment.

Python Code:
x = str()
x = x + 'H'
print(x)
x = x + 'ello world'
print(x)
x = 'A completely new string'
print("String = ", x)
print("Length = ", len(x))

C Code:
**Attempt #1
#include <string.h>
/* x = x + 'h'; */

void pystr_append(struct pystr* self, char ch) {
    /* Need about 10 lines of code here */
    self->data[self->length] = self->data[self->length] + ch;
    self->length++;
    if ( self->length >= (self->alloc - 2) ) {
        self->alloc = self->alloc + 10;
        self->data = (char *)
            realloc(self->data, self->alloc);
    }
}

/* x = x + "hello"; */

void pystr_appends(struct pystr* self, char *str) {
    /* Need a line or two of code here */
    int alloc = self->alloc;
    for (self->length=0; self->length <= alloc; ) {
         pystr_append(self, str[self->length-1]);
    }
}

/* x = "hello"; */

void pystr_assign(struct pystr* self, char *str) {
    /* Need about three lines of code here */
    self->data[0] = '\0';
    self->alloc = 22;
    pystr_appends(self, str);
    strcpy(self->data, str);
}


** Solution #1
#include <stdio.h>
#include <stdlib.h>

struct pystr
{
    int length;
    int alloc; /* the length of *data */
    char *data;
};

/* Constructor - x = str() */
struct pystr * pystr_new() {
    struct pystr *p = malloc(sizeof(*p));
    p->length = 0;
    p->alloc = 10;
    p->data = malloc(10);
    p->data[0] = '\0';
    return p;
}

/* Destructor - del(x) */
void pystr_del(const struct pystr* self) {
    free((void *)self->data); /* free string first */
    free((void *)self);
}

void pystr_dump(const struct pystr* self)
{
    printf("Pystr length=%d alloc=%d data=%s\n",
            self->length, self->alloc, self->data);
}

int pystr_len(const struct pystr* self)
{
    return self->length;
}

char *pystr_str(const struct pystr* self)
{
    return self->data;
}

int main(void)
{
    setvbuf(stdout, NULL, _IONBF, 0);  /* Internal */

    struct pystr * x = pystr_new();
    pystr_dump(x);

    pystr_append(x, 'H');
    pystr_dump(x);

    pystr_appends(x, "ello world");
    pystr_dump(x);

    pystr_assign(x, "A completely new string");
    printf("String = %s\n", pystr_str(x));
    printf("Length = %d\n", pystr_len(x));
    pystr_del(x);
}

/* x = x + 'h'; */

void pystr_append(struct pystr* self, char ch) {
    // Check if reallocation is needed
    if ( self->length + 1 >= self->alloc ) {
        self->alloc = self->alloc + 10;
        self->data = (char *)
            realloc(self->data, self->alloc);
    }
    // Append the character
    self->data[self->length] = ch; 
    // Increment the length
    self->length++;
    // Ensure string is null-terminated
    self->data[self->length] = '\0';
}

/* x = x + "hello"; */

void pystr_appends(struct pystr* self, char *str) {
    int i;
    // Iterate through the string using a counter
    for (i=0; str[i] != '\0'; i++) {
         pystr_append(self, str[i]);
    }
}

/* x = "hello"; */

void pystr_assign(struct pystr* self, char *str) {
    // Clear existing string and reset length
    self->data[0] = '\0';
    self->length = 0;
    // Copy the new string
    pystr_appends(self, str);
}

Input:
N/A

Output:
Pystr length=0 alloc=10 data=
Pystr length=1 alloc=10 data=H
Pystr length=11 alloc=20 data=Hello world
String = A completely new string
Length = 23

Notes:
- The lecture provided the code for increasing the allocation. If the length started to exceed the allocation
  then the realloc() function was used to add 10 more to the allocated memory amount. I used that to initially
  start writing the pystar_append() function. The pystar_append() function involved using numerous pointers 
  and incrementing. 
- For the pystr_appends() function, I used a for loop and had to make sure the alloc was an integer and 
  assigned to a variable or else the for loop condition would not recognize self->alloc as the value 10. 
  Only when I assigned int alloc = self->alloc did it recognize it as 10. This for loop also ran the 
  pystr_append() function repeatedly to affix the string to the variable. 
- The pystar_assign() was a lot trickier and I couldn't quite figure out how to do it without using the 
  string.h library and the dedicated strcpy() function. My end result was assigning the self->data to the 
  null terminator '\0' then reallocating manually for the allocation to the string size. After that, I called
  the pystr_appends() function and finally the strcpy() function. When I used pystr_dump() in the
  pystr_assign() function to check the printed length, alloc and data it had extra allocation by 2 and the
  allocation assignment that I needed for self->alloc was off by 1. Tried a while to look through the code
  and troubleshoot but couldn't quite figure out what was causing this discrepancy.

Suggestions and Final Thoughts:
- In the if statement for checking if reallocation is needed, another way to check if the new length will
   meet or exceed the allocation size is to use "if (self-> length + 1 >= self->alloc)".
- Rather than performing arithmetic for assigning the appending of characters in the line
  "self->data[self->length] = self->data[self->length] + ch;", it is best to just assign the character to
  the variable using "self->data[self->length] = ch;". 
- When strings are modified, it is best to ensure the string is null-terminated using '\0' as in the line
  "self->data[self->length] = '\0'
- Initially, I created a for loop by using an initializer integer variable i but for some reason had tried
  to incorporate the self->length variable into the for loop which ended up being too complicated. Sticking
  with the variable i ensures there's no mix up in the function itself. The for loop ended up being a 
  traversal through a string until the end of the string itself, or the null terminator and incremented each
  time. It also called the pystr_append() function multiple times to carry out the appending operation.
- For the pystr_assign() function, I had the correct logic when I made my first few attempts but my
  pystr_appends() and pystr_append() functions did not correspond correctly so it would throw off the 
  final result. I did use the null terminator for self->data[0] and self->length = 0 along with calling the
  pystr_appends() function within pystr_assign() function.
- Seems like overall, I made the problem a little more difficult than I needed to by trying to incorporate
  all the pointers that I could but some functions didn't need to have the pointers. Still was good practice
  and challenge in the end.

############################################################################################################

Source:
C Programming for Everybody - Implement a Python list class

Question:
You will a set of supporting functions using the following structures to implement a subset of the Python list class in C. 
Some code and method signatures have been provided for you as well as a main() program and some support routines from the lecture slides. 
There is a good deal of discussion of this application in the lecture materials associated with this assignment.

Python Code:
lst = list();
lst.append("Hello world");
print(lst)
lst.append("Catch phrase");
print(lst)
lst.append("Brian");
print(lst)
print("Length =", len(lst);

print("Brian?", lst.index("Brian"));

if "Bob" in lst:
    print("Bob?", lst.index("Bob"));
else:
    print("Bob? 404");

C Code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct lnode {
    char *text;
    struct lnode *next;
};

struct pylist {
  struct lnode *head;
  struct lnode *tail;
  int count;
};

/* Constructor - lst = list() */
struct pylist * pylist_new() {
    struct pylist *p = malloc(sizeof(*p));
    p->head = NULL;
    p->tail = NULL;
    p->count = 0;
    return p;
}

/* Destructor - del(lst) */
void pylist_del(struct pylist* self) {
    struct lnode *cur, *next;
    cur = self->head;
    while(cur) {
        free(cur->text);
        next = cur->next;
        free(cur);
        cur = next;
    }
    free((void *)self);
}

int main(void)
{
    setvbuf(stdout, NULL, _IONBF, 0);  /* Internal */

    struct pylist * lst = pylist_new();
    pylist_append(lst, "Hello world");
    pylist_print(lst);
    pylist_append(lst, "Catch phrase");
    pylist_print(lst);
    pylist_append(lst, "Brian");
    pylist_print(lst);
    printf("Length = %d\n", pylist_len(lst));
    printf("Brian? %d\n", pylist_index(lst, "Brian"));
    printf("Bob? %d\n", pylist_index(lst, "Bob"));
    pylist_del(lst);
}

/* print(lst) */
void pylist_print(struct pylist* self)
{
    int i;
    struct lnode *cur;
    printf("[");
    /* Loop until the current pointer reaches NULL, 
    NULL signifies end of list */
    for(i=0, cur=self->head; cur != NULL; cur=cur->next, i++) { 
        printf("'%s'", cur->text);
        /* Place commas only between list entries */
        if ( i < self->count-1 ) {
            printf(", ");
        }
    }
    printf("]\n");
}

/* len(lst) */
int pylist_len(const struct pylist* self)
{
    return self->count;
}

/* lst.append("Hello world") */
void pylist_append(struct pylist* self, char *str) {
    /* Allocate space for save variable
       Copy string to "save"
       increment count by 1 */
    char *save = (char *) malloc(strlen(str)+1);
    strcpy(save, str);
    self->count++;
  
    /* Allocate space only for the new node */
    struct lnode *new = (struct lnode *)
        malloc(sizeof(struct lnode));
 
    /* Check if allocation failed */
    if ( new == NULL ) {
        return;
    }
  
    /* List is not empty.
       Append new node by updating current tail's 'next' pointer.
       Update the list's 'tail' pointer to be the new node. */
    if ( self->tail != NULL ) {
        self->tail->next = new;
        new->text = save;
        new->next = NULL;
        self->tail = new;
    }
   
    /* List is empty. 
       Head and tail point to the new node */
    if ( self->head == NULL ) {
        new->text = save;
        self->head = new;
        self->tail = new;
    }    
}

/* lst.index("Hello world") - if not found -1 */
int pylist_index(struct pylist* self, char *str)
{
    struct lnode *cur;
    int i;
    /* Loop until the current pointer reaches NULL, 
       NULL signifies end of list */
    for(i=0, cur=self->head; cur != NULL; cur=cur->next, i++) {
        /* Check if the current node contains the target value
           If value found, return the index */
        if ( strcmp(cur->text, str) == 0 ) {
            return i;
        }
    }
    /* If the loop finishes without finding the value, return -1*/
    return -1;
}

Input:
N/A

Output:
['Hello world']
['Hello world', 'Catch phrase']
['Hello world', 'Catch phrase', 'Brian']
Length = 3
Brian? 2
Bob? -1

Notes:
- I started this problem with working on the pylist.append() function first. As the lecture had hinted, one
  of the chapter 6 problems that I had done on linked lists had the code necessary to create this function.
  The modifications made were to allocate space for a save variable, copy the string to save and increment
  the list count by 1 each time it was called. Also, since this was a character string instead of a integer
  value, I had to change some of the pointer values to 'save' for situations where if the list was or was not
  empty such as with "new->text = save;"
- The pylist_len() function was straightforward, since I incremented the self->count each time I called
  pylist_append(), it was a matter of returning "self->count" to get the length of the list. 
- The next function I worked on was the pylist_print(), this was pretty tricky as it was like another
  problem I was working on before where I didn't use a counter variable and tried to use a pointer variable. 
  It helped tremendously to use i as a counter variable. Once I created a for loop to traverse a list, it was 
  a matter of where to put each individual printf() function to simulate the Python list output like [ , , ]. 
  The trickiest part was how to get the commas to be within entries and not on the outsides of entries. That's
  where the i counter variable really helped.
- The pylist_index() function was another function that was used before in Chapter 6 problems for scanning
  through a list. I took my existing for loop from the pylist_print() function and added a conditional if
  statement that compared the pointer values to the string being called using the strcmp() function. If the
  strings were the same then it would be 0, and the index i was returned when calling the function. If there
  was not a match after the loop finished then the function returned -1.

Suggestions and Final Thoughts:
- The lines "new->text = save;" and "new->next = NULL;" can be placed outside of the if statements for the
  lists being empty or not. It sets the new node's properties and prevents duplication.
- The conditional statements could be unified using if/else instead of two if statements since they both
  deal with NULL situations.
  ex.
      if (self->head == NULL) {
          self->head = new;    // List is EMPTY: The new node is the head
      } 
      else {
          self->tail->next = new;     // List is NOT empty: Link the old tail to the new node
      }
      self->tail = new;         // Update the list's tail 
- There is a check to see if allocation failed for new. There should also be one for save as well.
  ex. 
      if (save == NULL) { 
          return 
      }

############################################################################################################

Source:
C Programming for Everybody - Implement a Python dict class

Question:
You will create a set of supporting functions using the following structure to implement a subset of the Python dict class in C. 
Some code and method signatures have been provided for you as well as a main() program and some support routines from the lecture slides. 
There is a good deal of discussion of this application in the lecture materials associated with this assignment.

Python Code:
dct = dict();
dct["z"] = "Catch phrase"
print(dct);
dct["z"] = "W"
print(dct):
dct["y"] = "B"
dct["c"] = "C"
dct["a"] = "D"
print(dct);
print("Length =", len(dct));
print("z=", dct.get("z", 404))
print("x=", dct.get("x", 404))
print("\nDump")
for key in dct:
    print(key+"="+dct(key))

C Code:
Attempt #1 (only the pydict_put function was revised)
/* x[key] = value; Insert or replace the value associated with a key */
void pydict_put(struct pydict* self, char *key, char *value)
{
    struct dnode *old = pydict_find(self, key);
  
    // If old key found then replace the value
    if ( old != NULL ) {
        // Free the data in the old value before allocating the new value
        free(old->value);
      
        // Allocate space for new savevalue variable
        char *savevalue = (char *) malloc(strlen(value)+1);
      
        // Check if allocation failed 
        if ( savevalue == NULL ) {
            return;
        }
       
        // Copy new value to savevalue
        strcpy(savevalue, value);
    }
  
    // If old key not found then insert key and value
    else {
        // Allocate space for savekey and savevalue variables
        char *savekey = (char *) malloc(strlen(key)+1);
        char *savevalue = (char *) malloc(strlen(value)+1);
  
        // Check if allocation failed 
        if ( savekey == NULL ) {
            return;
        }
        if ( savevalue == NULL ) {
            return;
        }
  
        // Copy key to savekey and value to savevalue
        strcpy(savekey, key);
        strcpy(savevalue, value);
  
        // Allocate space for new node
        struct dnode *new = (struct dnode *)
            malloc(sizeof(struct dnode));
  
        // Check if allocation failed 
        if ( new == NULL ) {
            return;
        }
  
        // Set new node properties
        new->key = savekey;
        new->value = savevalue;
        new->next = NULL;
  
        // Dict is empty: The new node is the head
        if ( self->head == NULL ) {
            self->head = new;
        }
        // Dict not empty: Link the old tail to the new node
        else {
           self->tail->next = new;
        }
  
        // Update the dict's tail
        self->tail = new;
  
        // Increment the counter
        self->count++;
    }
}


**Solution #1 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct dnode {
    char *key;
    char *value;
    struct dnode *next;
};

struct pydict {
  struct dnode *head;
  struct dnode *tail;
  int count;
};

/* Constructor - dct = dict() */
struct pydict * pydict_new() {
    struct pydict *p = malloc(sizeof(*p));
    p->head = NULL;
    p->tail = NULL;
    p->count = 0;
    return p;
}

/* Destructor - del(dct) */
void pydict_del(struct pydict* self) {
    struct dnode *cur, *next;
    cur = self->head;
    while(cur) {
        free(cur->key);
        free(cur->value);
        next = cur->next;
        free(cur);
        cur = next;
    }
    free((void *)self);
}

int main(void)
{
    struct dnode * cur;
    struct pydict * dct = pydict_new();

    setvbuf(stdout, NULL, _IONBF, 0);  /* Internal */

    pydict_put(dct, "z", "Catch phrase");
    pydict_print(dct);
    pydict_put(dct, "z", "W");
    pydict_print(dct);
    pydict_put(dct, "y", "B");
    pydict_put(dct, "c", "C");
    pydict_put(dct, "a", "D");
    pydict_print(dct);
    printf("Length =%d\n",pydict_len(dct));

    printf("z=%s\n", pydict_get(dct, "z"));
    printf("x=%s\n", pydict_get(dct, "x"));

    printf("\nDump\n");
    for(cur = dct->head; cur != NULL ; cur = cur->next ) {
        printf("%s=%s\n", cur->key, cur->value);
    }

    pydict_del(dct);
}

/* print(dct) */
/* {'z': 'W', 'y': 'B', 'c': 'C', 'a': 'D'} */
void pydict_print(struct pydict* self)
{
    int i;
    struct dnode *cur;
    printf("{");

    // Loop until current pointer reaches NULL, or end of dict
    for ( i=0, cur = self->head; cur != NULL; cur = cur->next, i++ ) {
        printf("'%s': '%s'", cur->key, cur->value);
        // Place commas only between dict entries
        if ( i < self->count-1 ) {
            printf(", ");
        }
    }
    printf("}\n");
}

int pydict_len(const struct pydict* self)
{
    return self->count;
}

/* find a node - used in get and put */
struct dnode* pydict_find(struct pydict* self, char *key)
{
    struct dnode *cur;
    int i;

    // Loop until current pointer reaches NULL, or end of dict
    for( i=0, cur = self->head; cur != NULL; cur = cur->next, i++ ) {
        // Check if the current node contains the target key,
        // if key found, return the current node
        if ( strcmp(cur->key, key) == 0 ) {
            return cur;
        }
    }

    // If loop finishes without finding the target key, return NULL
    return NULL;
}

/* x.get(key) - Returns NULL if not found */
char* pydict_get(struct pydict* self, char *key)
{
    struct dnode *entry = pydict_find(self, key);

    // If key is present in dict then return value, else return NULL
    if ( entry != NULL ) {
        return entry->value;
    }
    else {
        return NULL; 
    }
}

/* x[key] = value; Insert or replace the value associated with a key */
void pydict_put(struct pydict* self, char *key, char *value)
{
    struct dnode *old = pydict_find(self, key);
  
    // If old key found then replace the value
    if ( old != NULL ) {
        // Allocate space for new savevalue variable
        char *savevalue = (char *) malloc(strlen(value)+1);
      
        // Check if allocation failed 
        if ( savevalue == NULL ) {
            return;
        }
       
        // Copy new value to savevalue
        strcpy(savevalue, value);
        
        // Free the data in the old value if allocation was successful
        free(old->value);
      
        // Assign to node
        old->value = savevalue;
    }
  
    // If old key not found then insert key and value
    else {
        // Allocate space for savekey and savevalue variables
        char *savekey = (char *) malloc(strlen(key)+1);
        char *savevalue = (char *) malloc(strlen(value)+1);

        // Allocate space for new node
        struct dnode *new = (struct dnode *)
            malloc(sizeof(struct dnode));
  
        // Check if allocation failed 
        if ( savekey == NULL ) {
            return;
        }
        if ( savevalue == NULL ) {
            free(savekey);
            return;
        }
        if ( new == NULL ) {
            free(savekey);
            free(savevalue);
            return;
        }

        // Copy key to savekey and value to savevalue
        strcpy(savekey, key);
        strcpy(savevalue, value);
  
        // Set new node properties
        new->key = savekey;
        new->value = savevalue;
        new->next = NULL;
  
        // Dict is empty: The new node is the head
        if ( self->head == NULL ) {
            self->head = new;
        }
        // Dict not empty: Link the old tail to the new node
        else {
           self->tail->next = new;
        }
  
        // Update the dict's tail
        self->tail = new;
  
        // Increment the counter
        self->count++;
    }
}

Input:
N/A

Output:
{'z': 'Catch phrase'}
{'z': 'W'}
{'z': 'W', 'y': 'B', 'c': 'C', 'a': 'D'}
Length =4
z=W
x=(null)

Dump
z=W
y=B
c=C
a=D

Notes:
- I ended up reusing a lot of the code I had created in a past problem that involved creating functions that
  mimic a python list.
- For the pydict_print() function, the changes I made to existing code were renaming the struct datatype to
  dnode to denote a dictionary node, printing two strings separated by a colon and space, assigning the 
  current pointer to point to a key and value variable found in the struct dnode for printing the strings, 
  and printing curly braces instead of brackets. The function entailed declaring variables, using a for loop
  to loop through a dictionary with pointers and printing the corresponding key and value pairs, placing
  commas between dict entries using an if statement, and matching the format of a python dictionary using
  printf statements.
- The pydict_len() function was a matter of using a pointer to a variable named count that was assigned in 
  the struct pydict.
- The pydict_find() function was similar to the pydict_print() function in terms of declared variables and
  the for loop but the expressions in the for loop were different. These conditions chcecked if the current
  node contained the target key and if the key was found then the current node was returned. If the loop
  finished without finding the target key then the function returned NULL.
- The pydict_get() function called an existing function pydict_find() and assigned it to a pointer variable
  called entry in the struct dnode. If the key found in the function pydict_find() was present in the
  dictionary then the value was returned using a pointer that points from entry to the variable value in the
  struct dnode, otherwise the function returned NULL.
- The pydict_put() function inserted or replaced the value associated with a key based on if and else
  statements where a key had existed in the dictionary or not. This function called upon the
  pydict_find() function and assigned the results to a variable called old in the struct dnode. For the if
  condition, if the old key was found then the old value was replaced. The data in the old value was freed 
  before allocating and setting the new value to the existing key. In the else condition, if the old key
  was not found then the key and value was inserted into the dictionary. Separate variables were declared
  to allocate space for the key and value being inserted. A new node was declared, allocated in the
  struct dnode, and set with properties using pointers. An if/else statement was created to determine 
  whether the dictionary was empty or not so that the new node would point to the head or the new node
  would link to the old tail respectively. At the end of the else condition, the dictionary's tail
  was updated to the new node and a counter was incremented.

Suggestions and Final Thoughts:
- In the pydict_put() function, I was missing the assignment of the node where the old variable pointing to
  the value would be changed to the newly allocated savevalue variable.
  ex.
      old->value = savevalue;
- To prevent a memory leak, it is best to have functions that clean up after themselves if any step of
  their processes fails. The free() function can be used in the if conditions that check if the allocation
  failed or not. If a successful allocation occurs then the free conditions can take place.
  ex.
      if (savevalue == NULL) {
          free(savekey);          // Clean up the key before leaving!
          return;
      }
      if (new_node == NULL) {
          free(savekey);          // Clean up everything 
          free(savevalue);        // Clean up everything
          return;
  ex.
      if ( old != NULL ) {
          char *savevalue = malloc(strlen(value) + 1);
          if (savevalue == NULL) {
              return;
          }
          strcpy(savevalue, value)
          free(old->value);               // Free AFTER successful malloc
          old->value = savevalue;
      }
- For the else block of the pydict_put() function, I refactored the code to group the declarations and 
  allocation first and then placed the checks for allocation failures with free() functions before performing
  any actions such as strcpy() or assigning properties.
  ex.
      // Allocate space for savekey and savevalue variables
      char *savekey = (char *) malloc(strlen(key)+1);
      char *savevalue = (char *) malloc(strlen(value)+1);

      // Allocate space for new node
      struct dnode *new = (struct dnode *)
          malloc(sizeof(struct dnode));
  
      // Check if allocation failed 
      if ( savekey == NULL ) {
          return;
      }
      if ( savevalue == NULL ) {
          free(savekey);
          return;
      }
      if ( new == NULL ) {
          free(savekey);
          free(savevalue);
          return;
      }

      // Copy key to savekey and value to savevalue
      strcpy(savekey, key);
      strcpy(savevalue, value);
- Checking for allocations failing code can be simplified.
  ex.
      if ( !savekey || !savevalue || !new ) {
          free(savekey);
          free(savevalue);
          free(new);
          return;
      }

############################################################################################################

Source:
C Programming for Everybody - Encapsulation

Question:
This assignment will refactor your implementation of your Python dict class from a previous assignment following the principle of encapsulation. 
We will rename member variables and functions to follow the Python convention that "private" variables start with a double underscore (a.k.a. dunder) in C.
We will also switch the method calls to be stored within the object structure. 
There is a good deal of discussion of this application in the lecture materials associated with this assignment.

Python Code:
N/A

C Code:
**Attempt #1
/* Add or update an entry in the Map */
void __Map_put(struct Map* self, char *key, int value) {
    struct MapEntry *old, *new;
    // Allocate space for new key
    char *new_key = (char *) malloc(strlen(key)+1);
  
    if ( key == NULL ) {
        return;
    }

    old = __Map_find(self, key);
    if ( old != NULL ) {
        old->value = value;
        return;
    }
  
    // Allocate space for new variable
    new = malloc(sizeof(*new));
  
    // Check if allocation failed 
    if ( new_key == NULL ) {
        return;
    }
    if ( new == NULL ) {
        free(new_key);
        free(new);
        return;
    }
  
    // Copy key to new_key
    strcpy(new_key, key);
  
    // Set new node properties
    new->key = new_key;
    new->value = value;

    // Dict is empty: The new node is the head
    if ( self->__head == NULL ) {
        self->__head = new;
    }
    // Dict not empty: Link the old tail to the new node
    else {
        self->__tail->__next = new;
    }
  
    // Update the dict's tail
    self->__tail = new;

    self->__count++;
}

/* Keep track of the size of the Map */
int __Map_size(struct Map* self)
{
    return self->__count;
}

/* Locate and return the value for the corresponding key or a default value */
int __Map_get(struct Map* self, char *key, int def)
{
    struct MapEntry *retval = __Map_find(self, key);

    // If key is present in dict then return value, else return def
    if ( retval == NULL ) {
        return def;
    }
    else {
        return retval->value;
    }
}

/* Allocate the Map object instance and fill it with defaults */
struct Map * Map_new() {
    struct Map *p = malloc(sizeof(*p));

    p->__head = NULL;
    p->__tail = NULL;
    p->__count = 0;
  
    p->put = &__Map_put;
    p->get = &__Map_get;
    p->size = &__Map_size;
    p->dump = &__Map_dump;
    p->del = &__Map_del;
    return p;
}


** Solution #1 (revised)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct MapEntry {
    char *key;  /* public */
    int value;  /* public */
    struct MapEntry *__prev;
    struct MapEntry *__next;
};

struct Map {
   /* Attributes */
   struct MapEntry *__head;
   struct MapEntry *__tail;
   int __count;

   /* Methods */
   void (*put)(struct Map* self, char *key, int value);
   int (*get)(struct Map* self, char *key, int def);
   int (*size)(struct Map* self);
   void (*dump)(struct Map* self);
   void (*del)(struct Map* self);
};

void __Map_del(struct Map* self) {
    struct MapEntry *cur, *next;
    cur = self->__head;
    while(cur) {
        free(cur->key);
        /* value is just part of the struct */
        next = cur->__next;
        free(cur);
        cur = next;
    }
    free((void *)self);
}

void __Map_dump(struct Map* self)
{
    struct MapEntry *cur;
    printf("Object Map count=%d\n", self->__count);
    for(cur = self->__head; cur != NULL ; cur = cur->__next ) {
         printf("  %s=%d\n", cur->key, cur->value);
    }
}

struct MapEntry* __Map_find(struct Map* self, char *key)
{
    struct MapEntry *cur;
    if ( self == NULL || key == NULL ) return NULL;
    for(cur = self->__head; cur != NULL ; cur = cur->__next ) {
        if(strcmp(key, cur->key) == 0 ) return cur;
    }
    return NULL;
}

/* Add or update an entry in the Map */
void __Map_put(struct Map* self, char *key, int value) {
    struct MapEntry *old, *new;

    // Check if valid input
    if ( key == NULL ) {
        return;
    }

    // If old key found then replace the value
    old = __Map_find(self, key);
    if ( old != NULL ) {
        old->value = value;
        return;
    }
 
    // Allocate space for new key
    char *new_key = (char *) malloc(strlen(key)+1);
  
    // Allocate space for new variable
    new = malloc(sizeof(*new));
  
    // Check if allocation failed 
    if ( new_key == NULL ) {
        return;
    }
    if ( new == NULL ) {
        free(new_key);
        return;
    }
  
    // Copy key to new_key
    strcpy(new_key, key);
  
    // Set new node properties
    new->key = new_key;
    new->value = value;
    new->__next = NULL;

    // Dict is empty: The new node is the head
    if ( self->__head == NULL ) {
        self->__head = new;
    }
    // Dict not empty: Link the old tail to the new node
    else {
        self->__tail->__next = new;
    }
  
    // Update the dict's tail
    self->__tail = new;

    self->__count++;
}

/* Keep track of the size of the Map */
int __Map_size(struct Map* self)
{
    return self->__count;
}

/* Locate and return the value for the corresponding key or a default value */
int __Map_get(struct Map* self, char *key, int def)
{
    struct MapEntry *retval = __Map_find(self, key);

    // If key is present in dict then return value, else return def
    if ( retval == NULL ) {
        return def;
    }
    else {
        return retval->value;
    }
}

/* Allocate the Map object instance and fill it with defaults */
struct Map * Map_new() {
    struct Map *p = malloc(sizeof(*p));
    
    if ( p == NULL) {
       return NULL;
    }
 
    p->__head = NULL;
    p->__tail = NULL;
    p->__count = 0;
  
    p->put = &__Map_put;
    p->get = &__Map_get;
    p->size = &__Map_size;
    p->dump = &__Map_dump;
    p->del = &__Map_del;
    return p;
}

int main(void)
{
    struct Map * map = Map_new();
    struct MapEntry *cur;

    /* Make sure we see all output up to an error */
    setvbuf(stdout, NULL, _IONBF, 0); 

    printf("Map test\n");
    map->put(map, "z", 8);
    map->put(map, "z", 1);
    map->put(map, "y", 2);
    map->put(map, "b", 3);
    map->put(map, "a", 4);
    map->dump(map);

    printf("size=%d\n", map->size(map));

    printf("z=%d\n", map->get(map, "z", 42));
    printf("x=%d\n", map->get(map, "x", 42));

    map->del(map);
}

Input:
N/A

Output:
Map test
Object Map count=4
  z=1
  y=2
  b=3
  a=4
size=4
z=1
x=42

Notes:
- For this problem, I refactored a lot of the code I used in a past problem when implementing a Python
  dictionary in the C language. I decided to start with more of the familiar functions like __Map_size(),
  __Map_get(), and Map_new(). Then I tackled the more difficult function __Map_put() last.
- The __Map_size() function keeps track of the size of the Map using a self pointer to the __count variable.
- The __Map_get() function locates and returns the value for the corresponding key or a default value. A
  variable pointer named retval is declared to call the __Map_find() function. If the key is present in the
  established dictionary then the value is returned, otherwise the default value is returned. The retval
  pointer points to the value variable in the struct MapEntry.
- The Map_new() function allocates the Map object instance and fills it with defaults. A pointer named p
  is established and allocated. The p pointer creates defaults for the attributes; __head, __tail, and __count.
  It also creates addresses for the methods; put, get, size, dump, and del.
- The __Map_put() function adds or updates an entry in the Map. Old and new pointer variables are declared
  in the struct MapEntry. A new_key pointer is declared and allocated. The old variable calls the __Map_find()
  function and the new variable is allocated for space. If the old variable is not NULL, then update the entry
  with the new value using the old pointer to the value variable. Allocation checks were performed after the
  allocation of space. Once checks were performed, the actions of copying the instance key to the new_key
  variable and setting new node properties where the new pointer points to the key and the value were
  established. If the dictionary is found to be empty then the new node is the head and if the dictionary
  is not found to be empty then link the old tail to the new node. The dictionary's tail is updated and the
  count is incremented at the end of all conditions.
- I noticed that I did not need to free the old value or allocate for new space compared to the past code
  I used for implementing a Python dictionary in the __Map_put() function.

Suggestions and Final Thoughts:
- Move the declaration and allocation of the new_key variable after the process of seeing if the entry
  exists in the Map. In my past approach, this occurred at the beginning of the __Map_put() function which
  could cause a leak in memory.
  ex.
       if ( key == NULL ) {
           return;
       }
       
       old = __Map_find(self, key);
       if ( old != NULL ) {
           old->value = value;
           return;
       }

       char *new_key = (char *) malloc(strlen(key)+1);
- Remove free(new) in the allocation checks for the __Map_put() function. The free(new) is not necessary 
  because it frees a NULL pointer.
  ex.
       if ( new_key == NULL ) {
           return;
       }
       if ( new == NULL ) {
           free(new_key);
           return;
       }
- Assign each new entry its own next pointer to NULL to avoid pointing to garbage memory for the __Map_put()
  function. 
  ex.
      new->__next = NULL;
- For the map_new() function, add a NULL safety after allocating the p pointer variable. This allows the
  call function to check if the map was actually created.
  ex.
      if ( p == NULL) {
          return NULL;
      }
- Reusing existing memory is better than freeing and re-allocating memory because it reduces heap
  fragmentation and improves performance.

############################################################################################################

Source:
C Programming for Everybody - Iteration

Question:
This assignment will add an iterator to your Map class. 
There is a good deal of discussion of iterators in the lecture materials associated with this assignment.
A good starting point for this assignment is the code used for the previous assignment. 
This assignment will add a new feature to the previous assignment.

Python Code:
N/A

C Code:
**Attempt #1
/* Add or update an entry in the Map */
void __Map_put(struct Map* self, char *key, int value) {
    struct MapEntry *old, *new;
  
    // Check if valid input
    if ( key == NULL ) return;
  
    // If old key found then replace the value
    old = __Map_find(self, key);
    if ( old != NULL ) {
        old->value = value;
        return;
    }

    // Allocate space for new key
    char *new_key = (char *) malloc(strlen(key)+1);
  
    // Allocate space for new variable
    new = malloc(sizeof(*new));
  
    // Check if allocation failed 
    if ( new_key == NULL ) {
        return;
    }
    if ( new == NULL ) {
        free(new_key);
        return;
    }
  
    // Copy key to new_key
    strcpy(new_key, key);
  
    // Set new node properties
    new->key = new_key;
    new->value = value;
    new->__next = NULL;

    // Dict is empty: The new node is the head
    if ( self->__head == NULL ) {
        self->__head = new;
    }
    // Dict not empty: Link the old tail to the new node
    else {
        self->__tail->__next = new;
    }
  
    // Update the dict's tail
    self->__tail = new;

    self->__count++;
}

/* Advance the iterator forwards or backwards and return the next item */
struct MapEntry* __MapIter_next(struct MapIter* self)
{
    struct MapEntry *retval = self->__current;
    
    // Returns NULL when there are no more entries
    if ( retval == NULL) {
        return NULL;
    }
    
    self->__current = self->__current->__next;
    return retval;
}

/* Create an iterator from the head */
struct MapIter* __Map_iter(struct Map* self)
{
    struct MapIter *iter = malloc(sizeof(*iter));
    
    // Returns NULL when there are no entries in the map
    if ( iter == NULL ) {
        return NULL; 
    }
  
    iter->__current = self->__head;
    iter->next = &__MapIter_next;
    iter->del = &__MapIter_del;
    return iter;
}

/* Allocate the Map object instance and fill it with defaults */
struct Map * Map_new() {
    struct Map *p = malloc(sizeof(*p));

    // Returns NULL if map was not created
    if ( p == NULL ) {
        return NULL; 
    }
  
    p->__head = NULL;
    p->__tail = NULL;
    p->__count = 0;
  
    p->put = &__Map_put;
    p->get = &__Map_get;
    p->size = &__Map_size;
    p->dump = &__Map_dump;
    p->del = &__Map_del;
    p->iter = &__Map_iter;
    return p;
}


** Solution #1
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct MapEntry {
    char *key;  /* public */
    int value;  /* public */
    struct MapEntry *__prev;
    struct MapEntry *__next;
};

struct MapIter {
   struct MapEntry *__current;

   struct MapEntry* (*next)(struct MapIter* self);
   void (*del)(struct MapIter* self);
};

struct Map {
   /* Attributes */
   struct MapEntry *__head;
   struct MapEntry *__tail;
   int __count;

   /* Methods */
   void (*put)(struct Map* self, char *key, int value);
   int (*get)(struct Map* self, char *key, int def);
   int (*size)(struct Map* self);
   void (*dump)(struct Map* self);
   struct MapIter* (*iter)(struct Map* self);
   void (*del)(struct Map* self);
};

void __Map_del(struct Map* self) {
    struct MapEntry *cur, *next;
    cur = self->__head;
    while(cur) {
        free(cur->key);
        /* value is just part of the struct */
        next = cur->__next;
        free(cur);
        cur = next;
    }
    free((void *)self);
}

void __MapIter_del(struct MapIter* self) {
    free((void *)self);
}

void __Map_dump(struct Map* self)
{
    struct MapEntry *cur;
    printf("Object Map count=%d\n", self->__count);
    for(cur = self->__head; cur != NULL ; cur = cur->__next ) {
         printf("  %s=%d\n", cur->key, cur->value);
    }
}

struct MapEntry* __Map_find(struct Map* self, char *key)
{
    struct MapEntry *cur;
    if ( self == NULL || key == NULL ) return NULL;
    for(cur = self->__head; cur != NULL ; cur = cur->__next ) {
        if(strcmp(key, cur->key) == 0 ) return cur;
    }
    return NULL;
}

int __Map_get(struct Map* self, char *key, int def)
{
    struct MapEntry *retval = __Map_find(self, key);
    if ( retval == NULL ) return def;
    return retval->value;
}

int __Map_size(struct Map* self)
{
    return self->__count;
}

/* Add or update an entry in the Map */
void __Map_put(struct Map* self, char *key, int value) {
    struct MapEntry *old, *new;
  
    // Check if valid input
    if ( key == NULL ) return;
  
    // If old key found then replace the value
    old = __Map_find(self, key);
    if ( old != NULL ) {
        old->value = value;
        return;
    }

    // Allocate space for new key
    char *new_key = (char *) malloc(strlen(key)+1);
  
    // Allocate space for new variable
    new = malloc(sizeof(*new));
  
    // Check if allocation failed 
    if ( new_key == NULL ) {
        return;
    }
    if ( new == NULL ) {
        free(new_key);
        return;
    }
  
    // Copy key to new_key
    strcpy(new_key, key);
  
    // Set new node properties
    new->key = new_key;
    new->value = value;
    new->__next = NULL;
    new->__prev = self->__tail;    // Set the back pointer

    // Dict is empty: The new node is the head
    if ( self->__head == NULL ) {
        self->__head = new;
    }
    // Dict not empty: Link the old tail to the new node
    else {
        self->__tail->__next = new;
    }
  
    // Update the dict's tail
    self->__tail = new;

    self->__count++;
}

/* Advance the iterator forwards or backwards and return the next item */
struct MapEntry* __MapIter_next(struct MapIter* self)
{
    struct MapEntry *retval = self->__current;
    
    // Returns NULL when there are no more entries
    if ( retval == NULL) {
        return NULL;
    }
    
    self->__current = self->__current->__next;
    return retval;
}

/* Create an iterator from the head */
struct MapIter* __Map_iter(struct Map* self)
{
    struct MapIter *iter = malloc(sizeof(*iter));
    
    // Returns NULL when there are no entries in the map
    if ( iter == NULL ) {
        return NULL; 
    }
  
    iter->__current = self->__head;
    iter->next = &__MapIter_next;
    iter->del = &__MapIter_del;
    return iter;
}

/* Allocate the Map object instance and fill it with defaults */
struct Map * Map_new() {
    struct Map *p = malloc(sizeof(*p));

    // Returns NULL if map was not created
    if ( p == NULL ) {
        return NULL; 
    }
  
    p->__head = NULL;
    p->__tail = NULL;
    p->__count = 0;
  
    p->put = &__Map_put;
    p->get = &__Map_get;
    p->size = &__Map_size;
    p->dump = &__Map_dump;
    p->del = &__Map_del;
    p->iter = &__Map_iter;
    return p;
}

int main(void)
{
    struct Map * map = Map_new();
    struct MapEntry *cur;
    struct MapIter *iter;

    /* Make sure we see all output up to an error */
    setvbuf(stdout, NULL, _IONBF, 0); 

    printf("Map test\n");
    map->put(map, "z", 8);
    map->put(map, "z", 1);
    map->put(map, "y", 2);
    map->put(map, "b", 3);
    map->put(map, "a", 4);
    map->dump(map);

    printf("size=%d\n", map->size(map));

    printf("z=%d\n", map->get(map, "z", 42));
    printf("x=%d\n", map->get(map, "x", 42));

    printf("\nIterate\n");
    iter = map->iter(map);
    while(1) {
        cur = iter->next(iter);
        if ( cur == NULL ) break;
	printf("%s=%d\n", cur->key, cur->value);
    }
    iter->del(iter);

    map->del(map);
}

Input:
N/A

Output:
Map test
Object Map count=4
  z=1
  y=2
  b=3
  a=4
size=4
z=1
x=42

Iterate
z=1
y=2
b=3
a=4

Notes:
- Most of the code necessary for solving this problem was found in the lecture slides. The only function
  that reused code was the __Map_put() function.
- The __Map_Iter_next() function advanced the iterator forwards or backwards and returns the next item.
  It involved declaring a retval variable in the struct MapEntry that was equal to self->__current value.
  If there were no entries then it would return NULL. Otherwise, the iterator would advance and return the
  retval.
- The __Map_iter() function created an iterator from the head. An iter variable was declared and allocated
  in the struct MapIter. If there were no entries in the map then the function would return NULL. The main
  process was having the iterator's current position be equivalent to the head of the map. The iterator 
  would also point to next using the address of the __MapIter_next function and point to del using
  the address of the __MapIter_del function. At the end, it would return the iter variable.
- The Map_new() function allocated the Map object instance filled it with defaults. I added the address
  of the __Map_iter function when the p pointer would point to the iter variable and a NULL safety check for
  seeing if the map was created or not.
- There wasn't much to actually write out for this code except for documentation to explain what each step
  did where I more or less used the code from the slides provided. If anything it was a lot of reusing or
  refactoring old existing code.

Suggestions and Final Thoughts:
- The __Map_iter() function traverses a collection without needing to know how it is stored internally.
  It allocates the struct MapIter. Sets iter->__curent to self->__head to tell the iterator to start at
  the very beginning of the linked list. Encapsulates the functions next and del so the caller can use them.
- The __MapIter_next() function handles the traversal logic and returns the current item and moves the 
  pointer forward. It stores the __curent node in a temporary variable called retval. It moves the __current
  pointer to the next node in the list (self->__curent->__next). If the __current is NULL then it returns
  NULL.
- To create a doubly linked list for reverse iteration, update the __Map_put() function to set the __prev
  pointer as the back pointer.
  ex.
      new->__prev = self->__tail;   // Set the back pointer

      if ( self ->__head == NULL) {
          self->__head = new;
      }
      else {
          self->__tail->__next = new;
      }

      self->__tail = new;
- For memory safety, a null check should be added the beginning of every function to check if self is NULL.

############################################################################################################

Source:
C Programming for Everybody - Build a HashMap

Question:
In this assignment, you will implement the Map class using a hash map as the underlying structure rather than a linked list. 
The easiest approach to this assignment is to start with your implementation of Map using a linked list and then adapt it from a single head value to an array of head values that each point to an independent linked list. 
We use the getBucket() function to choose the appropriate linked list head from the array of head values.

Python Code:
N/A

C Code:
** Attempt #1 (only the __HashMap_put function needed to be revised)
/* Add or update an entry in the HashMap */
void __HashMap_put(struct HashMap* self, char *key, int value) {
    int bucket;
    struct HashMapEntry *old, *new;
  
    // Check if valid input
    if ( key == NULL ) {
        return;
    }
  
    // If old key found then replace the value
    bucket = getBucket(key, self->__buckets);
    old = __HashMap_find(self, key, bucket);
    if ( old != NULL ) {
        old->value = value;
        return;
    }
  
    // Allocate space for new key and new value
    char *new_key = (char *) malloc(strlen(key)+1);
    char *new_value = (char *) malloc(strlen(key)+1);
  
    // Allocate space for new variable
    new = malloc(sizeof(*new));
  
    // Check if allocation failed 
    if ( new_key == NULL ) {
        return;
    }
    if ( new_value == NULL ) {
        return;  
    }
    if ( new == NULL ) {
        free(new_value);
        free(new_key);
        return;
    }
  
    // Copy key to new_key, value to new_value
    strcpy(new_key, key);
    strcpy(new_value, value);
 
    // Set new node properties
    new->key = new_key;
    new->value = value;
    new->__next = NULL;
  
    // HashMap is empty: The new node is the head
    if ( self->__heads[bucket] == NULL ) {
        self->__heads[bucket] = new;
    }
    
    // HashMap not empty: Link the old tail to the new node
    if ( self->__tails[bucket] != NULL ) {
        self->__tails[bucket]->__next = new; 
    }
                      
    // Set the back pointer
    new->__prev = self->__tails[bucket];
  
    // Update the dict's tail
    self->__tails[bucket] = new;
  
    // Increment the counter
    self->__count++;
}


** Solution #1
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct HashMapEntry {
    char *key;  /* public */
    int value;  /* public */
    struct HashMapEntry *__prev;
    struct HashMapEntry *__next;
};

struct HashMapIter {
    int __bucket;
    struct HashMap *__map;
    struct HashMapEntry *__current;

    struct HashMapEntry* (*next)(struct HashMapIter* self);
    void (*del)(struct HashMapIter* self);
};

struct HashMap {
    /* Attributes */
    int __buckets;
    struct HashMapEntry *__heads[8];
    struct HashMapEntry *__tails[8];
    int __count;

    /* Methods */
    void (*put)(struct HashMap* self, char *key, int value);
    int (*get)(struct HashMap* self, char *key, int def);
    int (*size)(struct HashMap* self);
    void (*dump)(struct HashMap* self);
    struct HashMapIter* (*iter)(struct HashMap* self);
    void (*del)(struct HashMap* self);
};

void __HashMap_del(struct HashMap* self)
{
    int i;
    struct HashMapEntry *cur, *next;

    for(i=0; i<self->__buckets; i++) {
        cur = self->__heads[i];
        while(cur) {
            free(cur->key);
            /* value is just part of the struct */
            next = cur->__next;
            free(cur);
            cur = next;
        }
    }
    free((void *)self);
}

void __HashMapIter_del(struct HashMapIter* self) {
    free((void *)self);
}

int getBucket(char *str, int buckets)
{
    int hash = 42;
    if ( str == NULL ) return 0;
    for( ; *str ; str++) {
        hash = ( hash << 3 ) ^ *str;
    }
    return hash % buckets;
}

void __HashMap_dump(struct HashMap* self)
{
    int i;
    struct HashMapEntry *cur;
    printf("Object HashHashMap count=%d buckets=%d\n", self->__count, self->__buckets);
    for(i = 0; i < self->__buckets; i++ ) {
        for(cur = self->__heads[i]; cur != NULL ; cur = cur->__next ) {
            printf(" %s=%d [%d]\n", cur->key, cur->value, i);
        }
    }
}

/* Searches the HashMap to see if the key exists and where it's located */
struct HashMapEntry* __HashMap_find(struct HashMap* self, char *key, int bucket)
{
    struct HashMapEntry *cur;
  
    if ( self == NULL || key == NULL ) {
        return NULL; 
    }
    
    for ( cur = self->__heads[bucket] ; cur != NULL ; cur = cur->__next ) {
        if ( strcmp(key, cur->key) == 0 ) {
            return cur; 
        }
    }
      
    return NULL;
}

/* Add or update an entry in the HashMap */
void __HashMap_put(struct HashMap* self, char *key, int value) {
    int bucket;
    struct HashMapEntry *old, *new;
    char *new_key;
  
    // Check if valid input
    if ( key == NULL ) {
        return;
    }
  
    // If old key found then replace the value
    bucket = getBucket(key, self->__buckets);
    old = __HashMap_find(self, key, bucket);
    if ( old != NULL ) {
        old->value = value;
        return;
    }
  
    // Allocate space for new key
    new_key = (char *) malloc(strlen(key)+1);
  
    // Allocate space for new variable
    new = malloc(sizeof(*new));
  
    // Check if allocation failed 
    if (new == NULL || new_key == NULL ) {
        free(new);
        free(new_key);
        return;
    }
  
    // Copy key to new_key
    strcpy(new_key, key);
 
    // Set new node properties
    new->key = new_key;
    new->value = value;
    new->__next = NULL;
    new->__prev = self->__tails[bucket];     // Set the back pointer
  
    // HashMap is empty: The new node is the head
    if ( self->__heads[bucket] == NULL ) {
        self->__heads[bucket] = new;
    }
    
    // HashMap not empty: Link the old tail to the new node
    if ( self->__tails[bucket] != NULL ) {
        self->__tails[bucket]->__next = new; 
    }
  
    // Update the HashMap's tail
    self->__tails[bucket] = new;
  
    // Increment the counter
    self->__count++;
}

/* Locate and return the value for the corresponding key or a default value */
int __HashMap_get(struct HashMap* self, char *key, int def)
{
    int bucket = getBucket(key, self->__buckets);
    struct HashMapEntry *retval = __HashMap_find(self, key, bucket);
  
    // If key is present in HashMap then return value, else return def
    if ( retval == NULL ) {
        return def;  
    }
  
    return retval->value;
}

int __HashMap_size(struct HashMap* self)
{
    return self->__count;
}

/* Advance the iterator forwards and return the next item */
struct HashMapEntry* __HashMapIter_next(struct HashMapIter* self)
{
    struct HashMapEntry *retval;
    
    /* If we are at the end of a chain and there are still more buckets
       scan for a bucket that is not NULL */
    while ( self->__current == NULL) {
        self->__bucket++;
      
        if ( self->__bucket >= self->__map->__buckets ) {
            return NULL; 
        }
      
        self->__current = self->__map->__heads[self->__bucket];
    }
  
    retval = self->__current;
  
    if ( self->__current != NULL ) {
        self->__current = self->__current->__next;  
    }
    
    return retval;
}

struct HashMapIter* __HashMap_iter(struct HashMap* map)
{
    struct HashMapIter *iter = malloc(sizeof(*iter));
    iter->__map = map;
    iter->__bucket = 0;
    iter->__current = map->__heads[iter->__bucket];
    iter->next = &__HashMapIter_next;
    iter->del = &__HashMapIter_del;
    return iter;
}

struct HashMap * HashMap_new() {
    struct HashMap *p = malloc(sizeof(*p));
    int i;

    p->__buckets = 8;
    for(i=0; i < p->__buckets; i++ ) {
        p->__heads[i] = NULL;
        p->__tails[i] = NULL;
    }

    p->__count = 0;

    p->put = &__HashMap_put;
    p->get = &__HashMap_get;
    p->size = &__HashMap_size;
    p->dump = &__HashMap_dump;
    p->iter = &__HashMap_iter;
    p->del = &__HashMap_del;
    return p;
}

int main(void)
{
    struct HashMap * map = HashMap_new();
    struct HashMapEntry *cur;
    struct HashMapIter *iter;

    setvbuf(stdout, NULL, _IONBF, 0);  /* Internal */

    printf("Testing HashMap\n");
    map->put(map, "z", 8);
    map->put(map, "z", 1);
    map->put(map, "y", 2);
    map->put(map, "b", 3);
    map->put(map, "a", 4);
    map->dump(map);

    printf("size=%d\n", map->size(map));

    printf("z=%d\n", map->get(map, "z", 42));
    printf("x=%d\n", map->get(map, "x", 42));

    printf("\nIterate\n");
    iter = map->iter(map);
    while(1) {
        cur = iter->next(iter);
        if ( cur == NULL ) break;
        printf(" %s=%d\n", cur->key, cur->value);
    }
    iter->del(iter);

    map->del(map);
}

Input:
N/A

Output:
Testing HashMap
Object HashHashMap count=4 buckets=8
 y=2 [1]
 a=4 [1]
 z=1 [2]
 b=3 [2]
size=4
z=1
x=42

Iterate
 y=2
 a=4
 z=1
 b=3

Notes:
- The majority of the code for this problem was provided in the lecture slides. A few parts from past 
  linked list and Map implementation problems were refactored and utilized as well.
- The __HashMap_find() function searches the HashMap to see if the key exists and where it's located using
  a for loop to traverse the multiple linked lists.
- The __HashMap_put() function adds or updates an entry in the HashMap. It checks if a key entry already
  exists and replaces the old value with the newly inputted value. If the key does not exist then space
  is allocated for the key and value, and the new key and new value are inputted in. It also increments
  the counter for the overall size of the HashMap.
- The __HashMap_get() function locates and returns the value for the corresponding key. If the key is not
  found in the HashMap then a default value is returned.
- The __HashMap_size() function returns the current count of the HasHMap that was incremented previously
  by the __HashMap_put() function.
- The __HashMapIter_next() function advances the iterator forwards and returns the next item. It traverses
  multiple linked lists within a HasHmap one at a time until it reaches the end. It uses bucket number to
  denote a linked list and loop through the values within the bucket.

Suggestions and Final Thoughts:
- For the __HashMap_put() function, removed "char *new_value = (char *) malloc(strlen(key)+1);" and
  "strcpy(new_value, value);" as they were not necessary and caused a memory leak. Value is stored as 
  an int already which means new_value would be redundant.
- An alternative to using malloc and strcpy is the strdup() function which performs string duplication.
  It calculates the length of the original string including the null terminator \0, allocates memory on
  the heap using malloc() for that exact size, copies the character from the source to the newly allocated
  memory, and returns a pointer to the new string.
  ex.
      // Allocate space for new key and copy key to new_key
      char *new_key = strdup(key);
- Consolidate and refactor the allocation check to be combined into one if statement rather than multiple
  if statements.
  ex.
      if (new == NULL || new_key == NULL) {
          free(new);
          free(new_key);
          return;
      }
- Move the step of "set the back pointer" to the "set the new node properties" step rather than at the end of
  the function.
  ex.
       // Set new node properties
       new->key = new_key;
       new->value = value;
       new->__next = NULL;
       new->__prev = self->__tails[bucket];     // Set the back pointer
- __HashMap_find() locates a specific entry in the map based on the target key and bucket provided. It
  traverses the linked lists to look for a match and if found then the pointer is returned, otherwise NULL.
- __HashMap_put() adds a new key-value pair or updates an existing one. It checks if the key already exists
  and overwrites it with a new inputted value if it does. If it does not exist then a new key is allocated,
  duplicated, and appended to the end of the linked list of that particular bucket. Finally, the count is
  incremented for the HashMap.
- __HashMap_get() retrieves data by calculating the hash/bucket for the key and calls __HashMap__find().
  It checks if the key doesn't exist and if it doesn't then a user-provided default value is returned.
  Otherwise, the return value for the existing key is returned.
- __HashMapIter_next() loops through every single item in the entire HashMap across different buckets.
  The iterator keeps track of the bucket and node that the loop is in. If there are valid nodes during
  traversal of the linked lists then the return value is saved. If there arent any then continue moving
  to the next bucket and traverse the next linked list until all buckets and lists are exhausted. The
  function returns NULL when all buckets and linked lists are traversed.

############################################################################################################

Source:
C Programming for Everybody - Build a LinkedTreeMap

Question:
Build a LinkedTreeMap.
There is a good deal of discussion of this assignment in the lecture materials associated with this assignment.
Loop through the tree from the root. 
If the matches the node, update the value and return.  
As the tree is scanned, keep track of the node containing largest key less than "key" in the variable left and the node containing the smallest key greater than "key" in the variable "right".  
So if the key is not found, left will be the closest lower neighbor or null and right will be the closest greater neighbor or null.

Python Code:
N/A

C Code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct TreeMapEntry {
    char *key;  /* public */
    int value;  /* public */
    struct TreeMapEntry *__next;
    struct TreeMapEntry *__left;
    struct TreeMapEntry *__right;
};

struct TreeMapIter {
   struct TreeMapEntry *__current;

   struct TreeMapEntry* (*next)(struct TreeMapIter* self);
   void (*del)(struct TreeMapIter* self);
};

struct TreeMap {
   /* Attributes */
   struct TreeMapEntry *__head;
   struct TreeMapEntry *__root;
   int __count;
   int debug;

   /* Methods */
   void (*put)(struct TreeMap* self, char *key, int value);
   int (*get)(struct TreeMap* self, char *key, int def);
   int (*size)(struct TreeMap* self);
   void (*dump)(struct TreeMap* self);
   struct TreeMapIter* (*iter)(struct TreeMap* self);
   void (*del)(struct TreeMap* self);
};

void __TreeMap_del(struct TreeMap* self) {
    struct TreeMapEntry *cur, *next;
    cur = self->__head;
    while(cur) {
        free(cur->key);
        /* value is just part of the struct */
        next = cur->__next;
        free(cur);
        cur = next;
    }
    free((void *)self);
}

void __TreeMapIter_del(struct TreeMapIter* self) {
    free((void *)self);
}

void __TreeMap_dump_tree(struct TreeMapEntry *cur, int depth)
{
    int i;
    if ( cur == NULL ) return;
    for(i=0;i<depth;i++) printf("| ");
    printf("%s=%d\n", cur->key, cur->value);
    if ( cur->__left != NULL ) {
        __TreeMap_dump_tree(cur->__left, depth+1);
    }
    if ( cur->__right != NULL ) {
        __TreeMap_dump_tree(cur->__right, depth+1);
    }
}

void __TreeMap_dump(struct TreeMap* self)
{
    struct TreeMapEntry *cur;
    printf("Object TreeMap count=%d\n", self->__count);
    for(cur = self->__head; cur != NULL ; cur = cur->__next ) {
         printf("  %s=%d\n", cur->key, cur->value);
    }
    printf("\n");
    __TreeMap_dump_tree(self->__root, 0);
    printf("\n");
}

/* Run a check to see if left and right are broken */
void __Map_check(struct TreeMap* self, struct TreeMapEntry *left, char *key, struct TreeMapEntry *right)
{
    if ( self->debug ) 
        printf("Check position: %s < %s > %s\n", (left ? left->key : "0"),
            key, (right ? right->key : "0") );

    /* Check our location in the linked list */
    if ( left != NULL ) {
        if ( left->__next != right ) {
            printf("FAIL left->__next != right\n");
        }
    } else {
        if ( self->__head != right ) {
            printf("FAIL self->__head != right\n");
        }
    }

    /* Check our location in the tree */
    if ( right != NULL && right->__left == NULL ) {
        /* OK */
    } else if ( left != NULL && left->__right == NULL ) {
        /* OK */
    } else {
        printf("FAIL Neither right->__left nor left->__right are available\n");
    }
}

#include "student.c"

int __TreeMap_size(struct TreeMap* self)
{
    return self->__count;
}

struct TreeMapIter* __TreeMap_iter(struct TreeMap* self)
{
    struct TreeMapIter *iter = malloc(sizeof(*iter));
    iter->__current = self->__head;
    iter->next = &__TreeMapIter_next;
    iter->del = &__TreeMapIter_del;
    return iter;
}

struct TreeMap * TreeMap_new() {
    struct TreeMap *p = malloc(sizeof(*p));

    p->__head = NULL;
    p->__root = NULL;
    p->__count = 0;
    p->debug = 0;

    p->put = &__TreeMap_put;
    p->get = &__TreeMap_get;
    p->size = &__TreeMap_size;
    p->dump = &__TreeMap_dump;
    p->iter = &__TreeMap_iter;
    p->del = &__TreeMap_del;
    return p;
}

int main(void)
{
    struct TreeMap * map = TreeMap_new();
    struct TreeMapEntry *cur;
    struct TreeMapIter *iter;

    setvbuf(stdout, NULL, _IONBF, 0);  /* Internal */

    map->debug = 1 == 1;

    printf("Testing TreeMap\n");
    map->put(map, "h", 42);
    map->put(map, "d", 8);
    map->put(map, "f", 5);
    map->put(map, "b", 123);
    map->dump(map);
    map->put(map, "k", 9);
    map->put(map, "m", 67);
    map->put(map, "j", 12);
    map->put(map, "f", 6);
    map->dump(map);

    printf("r=%d\n", map->get(map, "r", 42));
    printf("x=%d\n", map->get(map, "x", 42));

    printf("\nIterate\n");
    iter = map->iter(map);
    while(1) {
        cur = iter->next(iter);
        if ( cur == NULL ) break;
        printf(" %s=%d\n", cur->key, cur->value);
    }
    iter->del(iter);

    map->del(map);
}

Input:
N/A

Output:
Testing TreeMap
Check position: 0 < d > h
Check position: d < f > h
Check position: 0 < b > d
Object TreeMap count=4
  b=123
  d=8
  f=5
  h=42

h=42
| d=8
| | b=123
| | f=5

Check position: h < k > 0
Check position: k < m > 0
Check position: h < j > k
Object TreeMap count=7
  b=123
  d=8
  f=6
  h=42
  j=12
  k=9
  m=67

h=42
| d=8
| | b=123
| | f=6
| k=9
| | j=12
| | m=67

r=42
x=42

Iterate
 b=123
 d=8
 f=6
 h=42
 j=12
 k=9
 m=67

Notes:

Suggestions and Final Thoughts:

############################################################################################################

Source:
C Programming for Everybody - Count Words

Question:
You have to build everything except the main program here.
You should not need to write any new code.
Just gather your working TreeMap code and the supplied code together from the previous assignment and combine them together.

Python Code:
N/A

C Code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "student.c"

/**
 * The main program to read, parse, and count words
 */
int main(void)
{
    struct TreeMap * map = TreeMap_new();
    struct TreeMapEntry *cur;
    struct TreeMapIter *iter;
    char word[100];  /* Yes, this is dangerous */
    int i,j;
    int count, maxvalue;
    char *maxkey;

    setvbuf(stdout, NULL, _IONBF, 0);  /* Internal */

    /* Turn off debug */
    map->debug = 0;

    /* Loop over each word in the file */
    while (scanf("%s", word) != EOF) {
        for (i=0, j=0; word[i] != '\0'; i++) {
            if ( ! isalpha(word[i]) ) continue;
            word[j++] = tolower(word[i]);
        }
        word[j] = '\0';
        count = map->get(map, word, 0);
        map->put(map, word, count+1);
    }

    maxkey = NULL;
    maxvalue = -1;
    iter = map->iter(map);
    while(1) {
        cur = iter->next(iter);
        if ( cur == NULL ) break;
        if ( maxkey == NULL || cur->value > maxvalue ) {
            maxkey = cur->key;
            maxvalue = cur->value;
        }
    }
    iter->del(iter);
    printf("\n%s %d\n", maxkey, maxvalue);

    map->del(map);
}

Input:
the clown ran after the car and the car ran into the
tent and the tent fell down on the clown and the car

Output:
the 7

Notes:

Suggestions and Final Thoughts:

############################################################################################################
