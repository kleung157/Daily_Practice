C Practice Exercises

############################################################################################################

Source:
C Programming for Everybody - LBS290-13: Calculate Pay

Question:
This program will read an un-specified number of employee time records from input. 
Each time record will contain an employee number (integer), an employee rate per hour (float) and number of hours worked. 
You should give the employee time-and-a-half for overtime (hours over 40). 
You must write a function named calcpay() to calculate the pay. 
The function should have no return value and must not use any global variables. 
The calculated pay should be passed out of the function using call by location.

Python Code:
N/A

C Code:
#include <stdio.h>

int main() {
    int empno;
    float rate, hours, pay;
    void calcpay();

    while(1) {
        if ( scanf("%d %f %f",&empno,&rate,&hours) < 3 ) {
            break;
        }

        calcpay(&pay, rate, hours);

        printf("Employee=%d Rate=%.2f Hours=%.2f Pay=%.2f\n", empno, rate, hours, pay);
    } 
}

void calcpay(p,r,h)
    /* declare pointer pay, rate and hour as float variables */
    float *p,r,h; 
{
    /* if hours > 40, calculate pay for first 40 hours using rate 
    and add the calculated overtime pay for hours over 40. */
    if ( h > 40.0 ) { 
       *p = r * 40.0 + (1.5 * r * (h - 40.0));
    }
    /* pay pointer = rate x hours */
    else {
       *p = r * h;
    }
}

Input:
123 5.00 40
100 4.00 45
199 5.25 10

Output:
Employee=123 Rate=5.00 Hours=40.00 Pay=200.00
Employee=100 Rate=4.00 Hours=45.00 Pay=190.00
Employee=199 Rate=5.25 Hours=10.00 Pay=52.50

Notes:
- This question required creating a function that uses pointers to the address that was provided in the main 
  program. The main equation I used was pointer pay = rate x hour to determine the employee pay. An if 
  statement was applied to create the special condition of overtime pay that is time and a half for hours 
  over 40. Parentheses were used to calculate the overtime pay where overtime pay = 1.5 * rate * (hour – 40.0).
  This calculation was added to the first calculated 40 hours for regular pay which was regular = rate * 40.0.  For the else statement, I placed the main equation pointer pay = rate x hour for all other conditions.  
- In modern C the correct way to declare variables is in the function.  
  Ex. 
      void calcpay(float *p, float r, float h) 

############################################################################################################

Source:
C Programming for Everybody - Exercise RS-10: Concatenate Two Strings

Question:
Write a C program to prompt for two strings and concatenate them as shown in in the Python code below. 
Use the functions strcpy and strcat from the string.h library in your code. 
Pre-allocate your character arrays large enought to handle up to 100 characters on input for each string (i.e. do not use malloc as we have not yet covered that yet).

Python Code:
print('Enter two strings');
first = input()
second = input()
print(first + " & " + second)

C Code:
#include <stdio.h>
#include <string.h>

#define MAX_SIZE 100 /* define max size as 100 */

int main() {
    char dest[MAX_SIZE]; /* declare variables as characters with max_size */
    char first[MAX_SIZE];
    char second[MAX_SIZE];
  
    printf("Enter two strings\n"); /* print "Enter two strings" with new line */
  
    scanf("%99s", first); /* input first string with limit of 99 characters */
    scanf("%99s", second); /* input second string with limit of 99 characters */
  
    strcpy(dest, first); /* copy first string to destination variable */
    strcat(dest, " & "); /* concatenate destination variable with " & " */
    strcat(dest, second); /* concatenate second string to destination variable */
  
    printf("%s", dest); /* print first + " & " + second */
}

Input:
Kernighan
Ritchie

Output:
Enter two strings
Kernighan & Ritchie

Notes:
- Initially I solved the problem without using strcpy() and strcat(). I simply used scanf() to assign the 
  inputs to first and second variables. Then used the printf() statement to print out the desired output. 
  I couldn’t quite understand how strcpy() and strcat() functions worked with pointers but they already 
  contain pointers in the functions apparently. 
- My second iteration I decided to assign the results of each step to a variable called dest for destination.
  It was much easier to define the max size at the top using #define then placing that same constant in the 
  declarations for each variable. The scanf() function was used to limit inputs to 99 characters to prevent 
  buffer overflow. The strcpy() function requires a destination and source so I used the dest variable and
  the first variable string to copy the first string to assign a string to the destination. The strcat() also
  requires a destination and source. I used the dest variable once again and concatenated a “ & “ as the 
  prompt required. Then the dest variable was concatenated another time with the second variable string. 
  Lastly the dest variable was printed after all the steps using printf(). 
- scanf() function has potential overflow problems, better to use fgets() and remove the '\n' then sscanf(). 

############################################################################################################

Source:
C Programming for Everybody - Exercise RS-11: Write a function like Python rstrip()

Question:
Write a C function called py_rstrip() that removes spaces from the end of a string. 
This function modifies its parameter and should never be called with a constant value.

Python Code:
N/A

C Code:
#include <stdio.h>
#include <string.h>

int main() {
    char s1[] = "   Hello   World    ";
    void py_rstrip();

    py_rstrip(s1);
    printf("-%s-\n", s1);
}

void py_rstrip(char inp[]) /* declare type and variable in function */
{
    int len; /* Declare len variable as int */
    len = strlen(inp); /* Find the length of input and assign to len variable */
  
    while (len > 0 && inp[len-1] == ' ') { 
        len -= 1; /* For blank space, decrement by 1, move from right to left */
    }
  
    inp[len] = '\0'; /* Places the null terminator to end the string */
}

Input:
N/A

Output:
-   Hello   World-

Notes:
- Earlier I was trying to figure out how to remove the new line /n from fgets() function. Looking through 
  some code, I had saw that it could be used to solve the rstrip() function problem.
- An index starting from the right could be done by using the strlen() function to find the length of the 
  inputted string. At first, I had tried using an if statement and for loop to try to decrement the index each.
  time a white space was found. It did not work as well as a while loop. The len > 0 was a good idea for a 
  safety check in the sense that the string could create an error. I decided to use len -= 1 to decrement 
  rather than –-len since that seemed a bit less intuitive for me. Placing a null terminator to the end of the
  string ‘\0’ was important since I had removed it initially using len-1. So, assigning inp[len] = ‘\0’ at the 
  end of the while loop makes sense to end the rstrip(). 
- Remember to declare variables within the function for modern C and assign length of strings to an int and 
  not a char data type. 

############################################################################################################

Source:
C Programming for Everybody - Exercise RS-12: Write a function like Python lstrip()

Question:
Write a C function called py_lstrip() that removes whitespace (blanks, tabs, and newlines) from the beginning of a string. 
This function modifies its parameter and should never be called with a constant value.

Python Code:
N/A

C Code:
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int main() {
    char s1[] = "   Hello   World    ";
    void py_lstrip();

    py_lstrip(s1);
    printf("-%s-\n", s1);
}

void py_lstrip(char inp[]) /* Declare type and variable in function */
{
    int i = 0; /* Declare index and initialize to 0 */
    int j = 0; /* Declare new index, initialize to 0 for shifted string */
  
    /* Find the index of the first non white space character and increment by 1 */
    while ( inp[i] != '\0' && isspace(inp[i]) ) {
        i++;
    }
  
    /* Check if there is leading white space */
    if ( i == 0 ) {
        return; /* No white space found, do nothing */ 
    }
  
    /* Shift remaining characters back to the start (index j) */
    while ( inp[i] != '\0' ) {
        inp[j] = inp[i];
            i++;
            j++;
    }
    
    /* Place the null terminator at the end of the string */
    inp[j] = '\0';
}

Input:
N/A

Output:
-Hello   World    -

Notes:
- Thought that the lstrip() function would be easy and simple similar to the rstrip function() but it was 
  pretty different overall. I noticed a new library was included in the main program <ctype.h> that classifies
  and converts individual characters. Rather than using inp[i] == ‘ ‘ white space I ended up using isspace() 
  function as isspace(inp[i]).  
- The first non white space character needed to be found using a while loop and incremented by 1 for each 
  blank space continually until found. A second while loop was performed to copy the found white space 
  character index to the new index j. Then the resulting copied string was terminated using ‘\0’ 

############################################################################################################

Source:
C Programming for Everybody - LBS290-14 Play with Arrays

Question:
The program will create a 10 element array and read in 10 integers into the array. 
Then the program will print the integers backwards. 
Then the program will scan for entries in the array which contain the value 100 and print out the index of the entries with the number 100. 
The program will also count the number of entries which equal 100. 
The program should work even if there are no entries which equal 100. 
See the sample output for the expect format of the output.

Python Code:
N/A

C Code:
#include <stdio.h>

/* Define array size and target value constants */
#define ARRAY_SIZE 10 
#define TARGET_VALUE 100

int main() {
   /* Declare integer, value, array, and count variables */
   int i, v; 
   int arr[ARRAY_SIZE];
   int count=0; 
  
   /* Read in 10 integers into the array */
   for ( i = 0; i < ARRAY_SIZE; i++ ) {
       scanf("%d", &v);
       arr[i] = v;
   }
   
   /* Scan array entries backwards and print the array index and array value */
   for ( i = ARRAY_SIZE-1; i >= 0; i-- ) { 
       printf("numb[%d] = %d\n", i, arr[i]);
   }
   
   printf("\n");
   printf("Searching for entries equal to %d\n", TARGET_VALUE);
   printf("\n");
   
   /* Scan array entries that contain 100 and print out index of entries with 100.
      Increment the number of entries into the count variable */
   for ( i = 0; i < ARRAY_SIZE; i++ ) {
       if ( arr[i] == TARGET_VALUE ) {
           printf("Found %d at %d\n", TARGET_VALUE, i);
           count++;
       }
   }
  
   printf("\n");
   printf("Found %d entries with %d", count, TARGET_VALUE);
   
   return 0;
}

Input:
9
5
100
16
18
20
6
100
1
77

Output:
numb[9] = 77
numb[8] = 1
numb[7] = 100
numb[6] = 6
numb[5] = 20
numb[4] = 18
numb[3] = 16
numb[2] = 100
numb[1] = 5
numb[0] = 9

Searching for entries equal to 100

Found 100 at 2
Found 100 at 7

Found 2 entries with 100

Notes:
- Two out of three of the for loops needed for the problem were already provided. The first loop reads in the 
  10 integers into the array using the scanf() function and assigns the values to an array based on index 
  number. The second loop needed to be edited to print out the array indexes and array values in reverse order. 
  I changed the initialization for this loop to the max index number of integers provided in the earlier first 
  loop input then decremented by 1 to pass through the whole array. For the third for loop, it had similar 
  conditions as the first for loop to run through all the values in the array from lowest to highest indexes. 
  An if statement was added in the loop to count the number of entries that equaled 100 and printed out the 
  index to where the entry was found in the array. Lastly, a final print statement was run to show the count 
  of entries that equaled 100. 
- For suggestions on improvement, I had multiple times where I used the same numbers, so defining them as 
  constants at the top of the code makes more sense. I added ARRAY_SIZE and TARGET_VALUE to be 10 and 100 
  respectively. These constants were switched in the declarations, for loops, print statements, and if 
  statements. Also, for the second for loop instead of hard coding 9 as the highest index to initialize, 
  I used the ARRAY_SIZE constant and subtracted by 1 to get 9. One thing I didn’t change was removing the v 
  variable. This v variable could have been substituted with &arr[i] but I decided against it to keep the 
  clarity of storing the scanned values into a variable. 
  Ex.  
      for ( i = 0; i < ARRAY_SIZE; i++ ) { 
          scanf("%d", &arr[i]); 
      } 

############################################################################################################

Source:
C Programming for Everybody - LBS290-15 Play with Strings

Question:
You are to perform the following steps in a function named process(): 
(1) Print out the string you are passed.
(2) Count the number of characters in the string. 
(3) If there are more than 10 characters in the string print out the 10th character (line[9]) 
(4) Go through the string and replace every blank with a dash '-'
(5) Print out the new string with dashes.

Python Code:
N/A

C Code:
#include <stdio.h>
#include <string.h>

int main() {
    char line[1000];
    void process();

    strcpy(line,"Hi there and welcome to LBS290");
    process(line);
    strcpy(line,"I love C");
    process(line);
}

void process(char line[])
{
    /* Declare index and count variable */
    int i; 
    int count = (int)strlen(line);
  
    /* Print the original string passed */
    printf("\nString: %s\n", line);
  
    /* Scan through the string and replace blank spaces ' ' with dashes '-'.
       Increment the index by 1 to keep count of the number of characters */
    for ( i = 0; line[i] != '\0'; i++ ) {
        if ( line[i] == ' ' ) {
            line[i] = '-';
        }
    }
   
    /* Print the number of characters in the string */
    printf("Count=%d\n", count);
    
    /* If the string has more than 10 characters, print the 10th character */
    if ( count > 10 ) {
        printf("The ninth character is: %c\n", line[9]);
    }
    
    /* Print the modified string with dashes */
    printf("String: %s\n", line);
}

Input:
N/A

Output:
String: Hi there and welcome to LBS290
Count=30
The ninth character is: a
String: Hi-there-and-welcome-to-LBS290

String: I love C
Count=8
String: I-love-C

Notes:
- I started my approach by declaring the index variable within the defined function. There were 4 print 
  statements that needed to be created for each line that was passed through the process() function and some
  had certain conditions for them to be printed out. The original string passed into the function was printed
  once. The next print statement printed the number of characters in the string. This count of characters was
  done in a for loop that scanned through the inputted string and incremented by 1 to record the count. The 
  for loop also had an if statement that replaced any blank spaces ‘ ‘ with dashes ‘-’ for the last print 
  statement. The third print statement used an if statement to print if the number of characters in the 
  string was greater than 10. If it was true then print the 10th character at index 9.  
- The final output problem I ran into was the inconsistent number of new line characters ‘\n’ in the print 
  statement. The first provided print statement code had ‘\n’ in the beginning and end of the statement. 
  Every other print statement only needed one ‘\n’. 
- For suggestions, void functions do not need a return 0; at the end of the function. For clarity in the 
  count step, use the strlen() function since the string.h library is called in the main program code. 
  Remember to cast the strlen() function as an int because the return type of strlen() is an unsigned integer
  type. The for loop can be performed using pointers instead of using a declared index variable. 
  Ex. 
       char *p;  
       for ( p = line; *p != '\0'; p++) {  
           if ( *p == ' ' ) {  
               *p = '-';  
           } 
       } 

############################################################################################################

Source:
C Programming for Everybody - LBS-98: A Touring Machine

Question:
This is a subset of an important concept in Computer Science called a Turing Machine. 
We call it a "Touring Machine" because it "wanders around and does things in memory" similar to a Turing Machine. 
Your computer has 256 characters of memory. 
The machine keeps track of the "position" or the "head" where data is to be written. 
The starting position is zero. 
You are to read a sequence of instructions from input and perform those instructions. 
When there are no more instructions, print the memory out as a zero-terminated C character array. 
Here are the instructions you need to support:
42     Store this value into the memory at the current position
>      Move the "position" one to the right (i.e. position++);
<      Move the "position" one to the left (i.e. position--);
All of the numbers should be in the range of 0-255 so they fit into a C char variable.

Python Code:
N/A

C Code:
#include <stdio.h>

#define MAX_SIZE 256 /* Define constants */

int main()
{
    char memory[MAX_SIZE]; /* Declare variables */
    char token[MAX_SIZE];
    int position = 0;
    int value;
    int i;
  
    for (i = 0; i < MAX_SIZE; i++) { /* Set all cells to 0 to initialize memory */
        memory[i] = 0; 
    }

    while( scanf("%255s", token) == 1 ) { /* Read inputs and limit input size to MAXSIZE-1 */
        if ( token[0] == '>' && token[1] == '\0') { /* Move the position one to the right */
            if ( position < MAX_SIZE - 1) { /* Pointer bounds check */
                position++;
            }
            continue; /* Go to next token, don't treat as a number */
        }
      
        if ( token[0] == '<' && token[1] == '\0') { /* Move the position one to the left */
            if ( position > 0) { /* Pointer bounds check */
                position--;
            }
            continue; /* Go to next token, don't treat as a number */
        }
      
        if ( sscanf(token, "%d", &value) == 1 ) { /* Read token inputs as decimal values */
            if (value >= -128 && value <= 255) { /* Value range check */
                memory[position] = (char)value; /* Store value into memory at current index position */
            }
        }
    }
    printf("Memory:\n%s\n", memory);
    
    return 0;
}

Input:
42 > 114 > 105 > 97 > 
110 < < < < 66

Output:
Memory:
Brian

Notes:
- Tried to be more literal with the instructions and implement them into code. I started with if statements
  to create conditions for the input but couldn’t quite figure out initially how to store the values into the
  memory variable. There was another approach I played around with that involved using a switch() but that 
  would mean declaring another variable and having to use other standard libraries. 
- I went back to my original approach of using if statements and reviewed some of the past practice questions
  I had and found that using sscanf() was necessary to read through the token inputs again as decimal values.
  I got as far as having the appropriate number of characters for the final output but the middle characters
  kept coming out wrong.  
- I was quite stumped for a while but at least a majority of the code that I had written was getting to a 
  viable solution. I simply had to add continue; statements to my if statements where ‘>’ and ‘<’ were
  considered. Another addition that was needed was having an if statement for the sscanf() function and to 
  make it equal to 1 or (TRUE).  
- For suggestions, add && token[1] == ‘\0’ to the command character if statements to ensure that the token is
  only the command character. Add pointer bounds check to only allow the position to stay within the bounds of
  the max size memory. Add a check for value range in the sscanf() function if statement to ensure value fits
  in to available 8-bit (byte) space. Set all cells to 0 (the null terminator ‘\0’ to initialize memory to
  prevent crashes. Cast the integer value as a character value.

############################################################################################################

Source:
C Programming for Everybody - 6-0 Linked Lists

Question:
You will write two function dealing with a simple strcuture as shown below. 
The first function will dump the internal values of the simpledate structure. 
The second will compute the day of the year similar to the sample code in Chapter 6 of the K&R book.

Python Code:
N/A

C Code:
#include <stdio.h>
#include <stdlib.h>

struct simpledate {
    int day;
    int month;
    int year;
};

static int day_tab[2][13] = {
  {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
  {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};

main() {
    void dump_date();
    printf("Playing with structures\n");
    struct simpledate sd;

    sd.year = 2023;
    sd.month = 2;
    sd.day = 11;
    dump_date(&sd);
    printf("Day of year %d\n", day_of_year(&sd));

    sd.year = 2023;
    sd.month = 9;
    sd.day = 15;
    dump_date(&sd);
    printf("Day of year %d\n", day_of_year(&sd));

    sd.year = 2024;
    sd.month = 9;
    sd.day = 15;
    dump_date(&sd);
    printf("Day of year %d\n", day_of_year(&sd));
}

int day_of_year(pd) /* set day of year from month, day */
struct simpledate *pd;
{
    int i, day, leap;

    day = pd->day;
    leap = pd->year % 4 == 0 && pd->year % 100 != 0 || pd->year % 400 == 0;
    for (i = 1; i < pd->month; i++)
        day += day_tab[leap][i];
    return (day);
}

void dump_date(pd) /* print date from year, month, day */
struct simpledate *pd;
{
    /* The date should be in the following format - note that */
    /* The month and day are always two digits with leading zeros */
    if ( pd->month < 10 && pd->day < 10 ) {  
        printf("%d/0%d/0%d\n", pd->year, pd->month, pd->day);
    }
    else if ( pd->month < 10 && pd->day >= 10 ) {
        printf("%d/0%d/%d\n", pd->year, pd->month, pd->day);
    }
    else if ( pd->month >= 10 && pd->day < 10 ) {
        printf("%d/%d/0%d\n", pd->year, pd->month, pd->day);
    }
    else {
        printf("%d/%d/%d\n", pd->year, pd->month, pd->day);
    }
}

Input:
N/A

Output:
Playing with structures
2023/02/11
Day of year 42
2023/09/15
Day of year 258
2024/09/15
Day of year 259

Notes:
- For the day_of_year() function, a structure variable called simpledate with a pointer *pd was included in 
  the function. I used the same code that was in the K&R book as it was alluded to in the prompt. The code
  contained declared integer variables i, day and leap. The i variable was used in a for loop to increment 
  until it reached a given month. Each time the loop ran, the day variable added the value that was indexed
  in the day_tab static variable using leap as the row index and i as the column index. The leap variable was
  either 0 or 1 based on a number of conditions to prove whether the given year was a leap year or not. 
  Also, the day variable was initialized with the given day before performing the for loop. At the end, the 
  day of year was returned.
- In the dump_date() function, I constructed numerous conditional statements using if, elseif and else to
  cover scenarios to print the date in the desired format having a leading zero if the month digit was less
  than 10 or if the day digit was less than 10. There probably is a better way to do it but that was the
  solution that I came up with to cover edge cases.
- For suggestions, using a format specifier like %.2d or %02d would be easier to handle leading zeros. This
  skips having to using the conditional statements. Also the structure variables with pointers can be defined
  in the functions themselves instead of outside.
  ex.
      printf("%04d/%02d/%02d\n", pd->year, pd->month, pd->day);
  ex.
      int day_of_year(struct simpledate *pd)

############################################################################################################

Source:
C Programming for Everybody - 6-A Linked Lists

Question:
You will write a function list_add() to append an integer to the end of a linked list. 
You will also write a function called list_find() that will return the list node containing the integer value or NULL if the value is not in the list.

Python Code:
N/A

C Code:
#include <stdio.h>
#include <stdlib.h>

struct lnode {
    int value;
    struct lnode *next;
};

struct list {
  struct lnode *head;
  struct lnode *tail;
};

int main()
{
    void list_add();
    void list_dump();
    struct lnode * list_find();

    struct list mylist;
    struct lnode * mynode;

    mylist.head = NULL;
    mylist.tail = NULL;

    list_add(&mylist, 10);
    list_add(&mylist, 20);
    list_add(&mylist, 30);
    list_dump(&mylist);

    mynode = list_find(&mylist, 42);
    if ( mynode == NULL ) {
        printf("Did not find 42\n");
    } else {
        printf("Looked for 42, found %d\n", mynode->value);
    }

    mynode = list_find(&mylist, 30);
    if ( mynode == NULL || mynode->value != 30) {
        printf("Did not find 30\n");
    } else {
        printf("Found 30\n");
    }

    list_add(&mylist, 40);
    list_dump(&mylist);

}

void list_dump(lst)
    struct list *lst;
{
    struct lnode *cur;
    printf("\nDump:\n");
    for(cur=lst->head; cur != NULL; cur=cur->next) {
        printf("  %d\n", cur->value);
    }
}

/* Append the value to the end of the linked list. */
void list_add(lst, value)
    struct list *lst;
    int value;
{
    /* Allocate space only for the new node */
    struct lnode *new = (struct lnode *)
        malloc(sizeof(struct lnode));
  
    /* Check if allocation failed */
    if ( new == NULL ) {
        return;
    }
  
    /* Initialize the node's fields.
       Store the integer value directly.
       New node is always last, next is NULL */
    new->value = value; 
    new->next = NULL; 
  
    /* List is not empty.
       Append new node by updating current tail's 'next' pointer.
       Update the list's 'tail' pointer to be the new node. */
    if ( lst->tail != NULL ) {
        lst->tail->next = new;
        lst->tail = new;
    }
  
    /* List is empty. 
       Head and tail point to the new node */
    if ( lst->head == NULL ) {
        lst->head = new;
        lst->tail = new;
    }    
}

/* Scan function to search for a specific value */
struct lnode * list_find(lst, value)
    struct list *lst;
    int value;
{
    /* Initialize a moving pointer to the head of the list. */
    struct lnode *cur = lst->head;
    
    /* Loop until the current pointer reaches NULL, 
       NULL signifies end of list */
    while (cur != NULL) {
      
        /* Check if the current node contains the target value
           If value found, return the pointer to matching node */
        if ( cur->value == value ) {
            return cur;
        }
        /* Move to the next node */
        cur = cur->next;
    }
    
    /* If the loop finishes without finding the value, return NULL */
    return NULL;
}

Input:
N/A

Output:
Dump:
  10
  20
  30
Did not find 42
Found 30

Dump:
  10
  20
  30
  40

Notes:
- The lecture notes for Chapter 6 had code that added character lines into a list. This question asked for
  appending an integer to the end of a linked list using a similar list_add() function. At first, I used the
  same lecture code in my own version of a list_add() function to see what the output would look like. Since
  the question asked for an integer, I removed a lot of the string specific code like strcpy() and having to
  use a character save variable to allocate characters. Instead, I switched the save variable to be an integer
  and the malloc() allocation didn't use strlen() and simply used sizeof() of the integer value.
  ex. 
      int *save = (int *) malloc(sizeof(value));
- Turns out the integer save step was not necessary either for the final function output. After manipulating 
  the code for sometime, I had to figure out a way to save the values inputted in the function into a variable
  using pointers. The *new pointer was defined in the structure lnode and allocated for space already. A step
  was added to test if the allocation failed. The new pointer was used to initialize the node's fields such as
  value and next variables. Value was the value of the input from the function and next was NULL. Moving to
  the conditional statements, if a list was not empty based on the list not being NULL at the tail then the
  next pointer had the new node appended to it and the tail pointer was the new node. If a list is empty, then
  the head and tail pointers point to the new node.
- For the second part of the question regarding the list_find() function, I saw that the provided main code
  had a *cur pointer so I decided to declare that into the structure lnode as *cur = lst->head to initialize
  a moving pointer to the head of the list. With a moving pointer, a while loop could be used to scan through
  the earlier appended list until a NULL was reached. If the current node contained the target value then
  the current node was returned. Otherwise, the current node would continually move on to the next node. At
  the end of the loop, if the value was not found then a NULL value was returned.
- The list_add() function appended to the list, the list_dump() function traversed the list, and list_find()
  function searched through the list.
- Will need to review structures and pointers a lot more to fully grasp the concepts since this problem was
  a bit difficult at several points.
- For suggeestions and key takeaways, adding to the tail is O(1) constant time because of the tail pointer.
  The node's int value field provides the storage which eliminates the need for a separate malloc(sizeof(int)).
  Declaring variables should be in the function parameters rather than outside the function since it's the 
  old K&R style.

############################################################################################################

Source:
C Programming for Everybody - 6-B Linked List Delete

Question:
You will extend the previous assignment with list_add() and list_find() and add a function called list_delete() that will find and remove the node containing the integer value if it is in the list.

Python Code:
N/A

C Code:
#include <stdio.h>
#include <stdlib.h>

struct lnode {
    int value;
    struct lnode *next;
};

struct list {
  struct lnode *head;
  struct lnode *tail;
};

int main()
{
    void list_add();
    void list_dump();
    struct lnode * list_find();

    struct list mylist;
    struct lnode * mynode;

    mylist.head = NULL;
    mylist.tail = NULL;

    list_add(&mylist, 10);
    list_add(&mylist, 20);
    list_add(&mylist, 30);
    list_dump(&mylist);

    list_remove(&mylist, 42);

    list_remove(&mylist, 10);
    list_dump(&mylist);

    list_remove(&mylist, 30);
    list_dump(&mylist);

    list_add(&mylist, 40);
    list_dump(&mylist);

}

void list_dump(lst)
    struct list *lst;
{
    struct lnode *cur;
    printf("\nDump:\n");
    for(cur=lst->head; cur != NULL; cur=cur->next) {
        printf("  %d\n", cur->value);
    }
}

/* Append the value to the end of the linked list. */
void list_add(lst, value)
    struct list *lst;
    int value;
{
    /* Allocate space only for the new node */
    struct lnode *new = (struct lnode *)
       malloc(sizeof(struct lnode));
    
    /* Check if allocation failed */
    if ( new == NULL ) {
        return;
    }
  
    /* Initialize the node's fields.
       Store the integer value directly.
       New node is always last, next is NULL */
    new->value = value;
    new->next = NULL;
  
    /* List is not empty.
       Append the new node by updating current tail's 'next' pointer.
       Update the list's 'tail' pointer to be the new node. */
    if ( lst->tail != NULL ) {
        lst->tail->next = new;
        lst->tail = new;
    }
  
    /* List is empty.
       Head and tail point to the new node */
    if ( lst->head == NULL ) {
       lst->head = new;
       lst->tail = new;
    }
}

/* Remove the value from the linked list. */
void list_remove(lst, value)
    struct list *lst;
    int value;
{
    /* Initialize a moving pointer to the head of the list. 
       Include pointers for tracking previous node and for node to be freed */
    struct lnode *prev = NULL;
    struct lnode *cur = lst->head;
    struct lnode *temp = NULL;
  
    /* Loop until the current pointer reaches NULL,
       NULL signifies the end of list */
    while ( cur != NULL ) {
    
        /* Check if the current node contains the target value */
        if ( cur->value == value ) {
          
            /* Case 1: Node found at head of list (prev is NULL) 
               New head is next node */
            if ( prev == NULL ) {
                lst->head = cur->next;
            }
            /* Case 2: Node found in middle or at tail of list
               Unlink 'cur' by connecting 'prev' to 'cur's next */
            else {
                prev->next = cur->next;
            }
            
            /* Case 3: Node found at tail of list (cur->next is NULL)
               If it's the only node (prev == NULL) or the last node, update tail */
            if ( cur-> next == NULL ) {
                lst->tail = prev; 
            }
          
            /* Hold the pointer before freeing (memory leak prevention) */
            temp = cur;
          
            /* Deallocate memory for the removed node */
            free(temp);
          
            /* Removal complete, exit function */
            return;
        }
        /* If value not found in 'cur', move pointers to the next node */
        prev = cur;
        cur = cur->next;
    }
  
    /* If the loop finishes without finding the value, return NULL */
    return NULL;
}

Input:
N/A

Output:
Dump:
  10
  20
  30

Dump:
  20
  30

Dump:
  20

Dump:
  20
  40

Notes:
- I attempted to use the code that list_find() function had for the previous linked list question. Most of
  it was needed but the critical part was tracking the previous node with the current node since removing a
  value from a linked list requires finding the value to delete, unlinking it and readjusting the list as 
  necessary depending on if the value is in the start, middle, or end of list. I referenced the lecture
  slides to try to figure out a way to include extra declarations like the *prev pointer and understand the
  process of deleting items from a linked list from looking at drawn pictures and diagrams.
- I was missing a pointer for the node to be freed and needed to initialize it as "struct lnode *temp = NULL;".
  In the while loop, the if statement for checking if the current node contained the target value needed to
  have 3 separate if statement cases for if the value to be deleted was in the head, middle, or tail of the 
  list. If the node was found at the head of the list where "prev = NULL" then the new head becomes the next
  node using code "lst->head = cur->next". If the node was found at the middle of the list, the previous node
  is the next node using code "prev->next = cur->next". If the node was found at the end of the list, where
  "cur-> next == NULL" then the new tail is the previous node "lst->tail = prev". The next steps held the
  cur pointer which contained the node to be freed in a temp variable and it was deallocated using the free()
  function. Once the removal of the node was complete, the function is exited. Outside of this if statement
  and still within the while loop, if the value was not found in the 'cur' pointer then move pointers to the
  next node as "prev = cur" and "cur = cur->next". Lastly, if the while loop finishes without finding the value
  to remove then do nothing or printf("Value %d not found in the list.\n", value);
- Will need to review the diagrams for delete item from linked list and doubly linked list in the lecture
  slides. Also still not that great with pointers, structures and linked lists in general yet. Whole chapter
  6 will be reviewed more thoroughly.

############################################################################################################
